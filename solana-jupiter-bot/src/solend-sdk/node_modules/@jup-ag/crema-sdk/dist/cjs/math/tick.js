"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.uiPrice2LamportPrice = exports.lamportPrice2uiPrice = exports.uiPrice2Tick = exports.tick2UiPrice = exports.swapB2A = exports.swapA2B = exports.maxAmountB = exports.maxAmountA = exports.calculateSwapB2A = exports.calculateSwapA2B = exports.getNearestTickByPrice = exports.getNearestTickBySqrtPrice = exports.getNearestTick = exports.tick2Price = exports.price2Tick = exports.tick2SqrtPrice = exports.sqrtPrice2Tick = exports.MIN_SQRT_PRICE = exports.MAX_SQRT_PRICE = exports.MIN_PRICE = exports.MAX_PRICE = exports.PRICE_OFFSET = exports.PIECES = exports.MIN_TICK = exports.MAX_TICK = void 0;
const tslib_1 = require("tslib");
const decimal_js_1 = require("decimal.js");
const tiny_invariant_1 = tslib_1.__importDefault(require("tiny-invariant"));
// The max ticker
exports.MAX_TICK = 443632;
// export const MAX_TICK = 552648
// The min ticker
exports.MIN_TICK = -exports.MAX_TICK;
// The price pieces
// price = pow(PIECES, TICK)
exports.PIECES = new decimal_js_1.Decimal("1.0001");
exports.PRICE_OFFSET = new decimal_js_1.Decimal("1e-12");
exports.MAX_PRICE = exports.PIECES.pow(exports.MAX_TICK).add(exports.PRICE_OFFSET);
exports.MIN_PRICE = exports.PIECES.pow(exports.MIN_TICK).add(exports.PRICE_OFFSET);
exports.MAX_SQRT_PRICE = exports.PIECES.pow(exports.MAX_TICK / 2)
    .add(exports.PRICE_OFFSET)
    .toDP(12);
exports.MIN_SQRT_PRICE = exports.PIECES.pow(exports.MIN_TICK / 2)
    .sub(exports.PRICE_OFFSET)
    .toDP(12);
/**
 * Get the tick by sqrt price
 *
 * @param sqrtPrice the sqrt price
  let afterSqrtPrice = liquity.div(amountIn.add(liquity.div(upperSqrtPrice)));
 */
function sqrtPrice2Tick(sqrtPrice) {
    (0, tiny_invariant_1.default)(sqrtPrice.lessThanOrEqualTo(exports.MAX_SQRT_PRICE), `Invalid sqrtPrice: ${sqrtPrice.toString()} Max: ${exports.MAX_SQRT_PRICE.toString()}, too large`);
    (0, tiny_invariant_1.default)(sqrtPrice.greaterThanOrEqualTo(exports.MIN_SQRT_PRICE), `Invalid sqrtPrice: ${sqrtPrice.toString()}, Min: ${exports.MIN_SQRT_PRICE.toString()}, too small`);
    return sqrtPrice.pow(2).log(exports.PIECES).toDP(0, decimal_js_1.Decimal.ROUND_HALF_UP).toNumber();
}
exports.sqrtPrice2Tick = sqrtPrice2Tick;
/**
 * Get the sqrt price by tick
 * @param tick the tick
 * @returns the sqrt price
 */
function tick2SqrtPrice(tick) {
    (0, tiny_invariant_1.default)(tick >= exports.MIN_TICK && tick <= exports.MAX_TICK, `Invalid tick: ${tick}, must be in range [${exports.MIN_TICK}, ${exports.MAX_TICK}]`);
    return exports.PIECES.pow(tick / 2);
}
exports.tick2SqrtPrice = tick2SqrtPrice;
/**
 * Get the tick by price
 * @param price the price
 * @returns the tick
 */
function price2Tick(price) {
    (0, tiny_invariant_1.default)(price.lessThan(exports.MAX_PRICE), `Invalid price:${price.toString()} Max: ${exports.MAX_PRICE.toString()},  too large`);
    (0, tiny_invariant_1.default)(price.greaterThan(exports.MIN_PRICE), `Invalid price:${price.toString()} Min: ${exports.MIN_PRICE.toString()}, too small`);
    return price.log(exports.PIECES).toDP(0, decimal_js_1.Decimal.ROUND_HALF_UP).toNumber();
}
exports.price2Tick = price2Tick;
/**
 * Get the price by tick
 * @param tick the tick
 * @returns the price
 */
function tick2Price(tick) {
    (0, tiny_invariant_1.default)(tick >= exports.MIN_TICK && tick <= exports.MAX_TICK, `Invalid tick: ${tick}, must be in range [${exports.MIN_TICK.toString()}, ${exports.MAX_TICK.toString()}]`);
    return exports.PIECES.pow(tick);
}
exports.tick2Price = tick2Price;
/**
 * Get the nearest valid tick
 * @deprecated please use {@link getNearestTickBySqrtPrice Or getNearestTickByPrice} instead
 * @param sqrtPrice the sqrt price
 * @param tickSpace the tick space
 * @returns the tick or null
 */
function getNearestTick(sqrtPrice, tickSpace) {
    return getNearestTickBySqrtPrice(sqrtPrice, tickSpace);
}
exports.getNearestTick = getNearestTick;
/**
 * Get the nearest valid tick for positions
 * @param sqrtPrice the sqrt price
 * @param tickSpace the tick space
 * @returns the tick or null(if the tick space <= 0)
 */
function getNearestTickBySqrtPrice(sqrtPrice, tickSpace) {
    (0, tiny_invariant_1.default)(tickSpace > 0 && tickSpace % 1 === 0, `Invalid tickSpace:${tickSpace}`);
    (0, tiny_invariant_1.default)(sqrtPrice.lessThan(exports.MAX_SQRT_PRICE), `Invalid sqrtPrice: ${sqrtPrice.toString()} Max: ${exports.MAX_SQRT_PRICE.toString()}, too large`);
    (0, tiny_invariant_1.default)(sqrtPrice.greaterThan(exports.MIN_SQRT_PRICE), `Invalid sqrtPrice: ${sqrtPrice.toString()}, Min: ${exports.MIN_SQRT_PRICE.toString()}, too small`);
    const t = sqrtPrice2Tick(sqrtPrice);
    const m = (t - exports.MIN_TICK) % tickSpace;
    if (m > tickSpace / 2) {
        return t - m + tickSpace;
    }
    return t - m;
}
exports.getNearestTickBySqrtPrice = getNearestTickBySqrtPrice;
/**
 * Get the nearest valid tick for positions
 * @param price the price
 * @param tickSpace the tick space
 * @returns the tick or null(if the tick space <= 0)
 */
function getNearestTickByPrice(price, tickSpace) {
    (0, tiny_invariant_1.default)(tickSpace > 0 && tickSpace % 1 === 0, `Invalid tickSpace:${tickSpace}`);
    (0, tiny_invariant_1.default)(price.lessThan(exports.MAX_PRICE), `Invalid price:${price.toString()} Max: ${exports.MAX_PRICE.toString()},  too large`);
    (0, tiny_invariant_1.default)(price.greaterThan(exports.MIN_PRICE), `Invalid price:${price.toString()} Min: ${exports.MIN_PRICE.toString()}, too small`);
    const t = price2Tick(price);
    const m = (t - exports.MIN_TICK) % tickSpace;
    if (m > tickSpace / 2) {
        return t - m + tickSpace;
    }
    return t - m;
}
exports.getNearestTickByPrice = getNearestTickByPrice;
/**
 *
 * @param ticks The tick array of token swap
 * @param currentSqrtPrice The current sqrt price of token swap
 * @param fee The fee rate of token swap
 * @param currentLiquity The current liquity of token swap
 * @param amountIn The amount in of token A
 * @returns amountOut:The amount out of token B, amountUsed:The used of amountIn, afterPrice:The price after calculate, afterLiquity: The liquity after calculate
 */
function calculateSwapA2B(ticks, currentSqrtPrice, fee, currentLiquity, amountIn) {
    (0, tiny_invariant_1.default)(amountIn.greaterThan(new decimal_js_1.Decimal(0)), "invalid amount in");
    (0, tiny_invariant_1.default)(currentLiquity.greaterThanOrEqualTo(new decimal_js_1.Decimal(0)), "invalid liquity");
    (0, tiny_invariant_1.default)(ticks.length > 0, "the ticks is empty");
    //let currentTick = sqrtPrice2Tick(currentSqrtPrice);
    (0, tiny_invariant_1.default)(ticks[0] !== undefined);
    (0, tiny_invariant_1.default)(currentSqrtPrice > ticks[0].tickPrice, "out of ticks");
    let liquity = currentLiquity;
    let out = new decimal_js_1.Decimal(0);
    let remind = amountIn;
    let remindWithFee = new decimal_js_1.Decimal(0);
    let feeUsed = new decimal_js_1.Decimal(0);
    let amountUsed = new decimal_js_1.Decimal(0);
    for (let i = ticks.length - 1; i >= 0; i--) {
        const ticksI = ticks[i];
        (0, tiny_invariant_1.default)(ticksI !== undefined);
        if (liquity.equals(new decimal_js_1.Decimal(0))) {
            currentSqrtPrice = ticksI.tickPrice.sub(exports.PRICE_OFFSET);
            liquity = liquity.sub(ticksI.liquityNet);
            //upperSqrtPrice = ticks[i].tickPrice;
            continue;
        }
        if (currentSqrtPrice < ticksI.tickPrice) {
            continue;
        }
        const upperSqrtPrice = currentSqrtPrice;
        const lowerSqrtPrice = ticksI.tickPrice;
        const maxAmountIn = maxAmountA(lowerSqrtPrice, currentSqrtPrice, liquity);
        const fullStepFee = maxAmountIn.mul(fee).toDP(0, decimal_js_1.Decimal.ROUND_DOWN);
        if (remind.lessThan(fullStepFee)) {
            remindWithFee = remind;
        }
        else {
            remindWithFee = remind.sub(fullStepFee);
        }
        if (maxAmountIn.greaterThanOrEqualTo(remindWithFee)) {
            remindWithFee = remind
                .mul(new decimal_js_1.Decimal(1).sub(fee))
                .toDP(0, decimal_js_1.Decimal.ROUND_UP);
            const { amountOut, afterSqrtPrice } = swapA2B(upperSqrtPrice, liquity, remindWithFee);
            amountUsed = amountUsed.add(remind);
            feeUsed = feeUsed.add(remind.sub(remindWithFee));
            return {
                amountOut: out.add(amountOut),
                amountUsed,
                feeUsed,
                afterPrice: afterSqrtPrice,
                afterLiquity: liquity,
            };
        }
        else {
            remind = remindWithFee.sub(maxAmountIn);
            amountUsed = amountUsed.add(maxAmountIn).add(fullStepFee);
            feeUsed = feeUsed.add(fullStepFee);
            out = out.add(maxAmountB(lowerSqrtPrice, upperSqrtPrice, liquity));
            liquity = liquity.sub(ticksI.liquityNet);
            currentSqrtPrice = ticksI.tickPrice.sub(exports.PRICE_OFFSET);
            //upperSqrtPrice = ticks[i].tickPrice;
        }
    }
    return {
        amountOut: out,
        amountUsed,
        feeUsed,
        afterPrice: currentSqrtPrice,
        afterLiquity: liquity,
    };
}
exports.calculateSwapA2B = calculateSwapA2B;
/**
 *
 * @param ticks The tick array of token swap
 * @param currentSqrtPrice The current sqrt price of token swap
 * @param fee The fee rate of token swap
 * @param currentLiquity The current liquity of token swap
 * @param amountIn The amount in of token B
 * @returns amountOut:The amount out of token B, amountUsed:The used of amountIn, afterPrice:The price after calculate, afterLiquity: The liquity after calculate
 */
function calculateSwapB2A(ticks, currentSqrtPrice, fee, currentLiquity, amountIn) {
    (0, tiny_invariant_1.default)(amountIn.greaterThan(new decimal_js_1.Decimal(0)), "invalid amount in");
    (0, tiny_invariant_1.default)(currentLiquity.greaterThanOrEqualTo(new decimal_js_1.Decimal(0)), "invalid liquity");
    (0, tiny_invariant_1.default)(ticks.length > 0, "the ticks is empty");
    //let currentTick = sqrtPrice2Tick(currentSqrtPrice);
    const lastTick = ticks[ticks.length - 1];
    (0, tiny_invariant_1.default)(lastTick !== undefined && currentSqrtPrice.lessThan(lastTick.tickPrice), "out of ticks");
    let liquity = currentLiquity;
    let out = new decimal_js_1.Decimal(0);
    let remind = amountIn;
    let remindWithFee = new decimal_js_1.Decimal(0);
    let amountUsed = new decimal_js_1.Decimal(0);
    let feeUsed = new decimal_js_1.Decimal(0);
    for (let i = 0; i < ticks.length; i++) {
        const ticksI = ticks[i];
        (0, tiny_invariant_1.default)(ticksI !== undefined);
        if (liquity.equals(new decimal_js_1.Decimal(0))) {
            currentSqrtPrice = ticksI.tickPrice.add(exports.PRICE_OFFSET);
            liquity = liquity.add(ticksI.liquityNet);
            continue;
        }
        if (currentSqrtPrice > ticksI.tickPrice) {
            continue;
        }
        const upperSqrtPrice = ticksI.tickPrice;
        const maxAmountIn = maxAmountB(currentSqrtPrice, upperSqrtPrice, liquity);
        const fullStepFee = maxAmountIn.mul(fee).toDP(0, decimal_js_1.Decimal.ROUND_DOWN);
        if (remind.lessThan(fullStepFee)) {
            remindWithFee = remind;
        }
        else {
            remindWithFee = remind.sub(fullStepFee);
        }
        if (maxAmountIn.greaterThanOrEqualTo(remindWithFee)) {
            remindWithFee = remind
                .mul(new decimal_js_1.Decimal(1).sub(fee))
                .toDP(0, decimal_js_1.Decimal.ROUND_UP);
            const { amountOut, afterSqrtPrice } = swapB2A(currentSqrtPrice, liquity, remindWithFee);
            amountUsed = amountUsed.add(remind);
            feeUsed = feeUsed.add(remind.sub(remindWithFee));
            return {
                amountOut: out.add(amountOut),
                feeUsed,
                amountUsed,
                afterPrice: afterSqrtPrice.pow(2),
                afterLiquity: liquity,
            };
        }
        else {
            remind = remindWithFee.sub(maxAmountIn);
            amountUsed = amountUsed.add(maxAmountIn).add(fullStepFee);
            feeUsed = feeUsed.add(fullStepFee);
            out = out.add(maxAmountA(currentSqrtPrice, upperSqrtPrice, liquity));
            liquity = liquity.add(ticksI.liquityNet);
            currentSqrtPrice = ticksI.tickPrice.add(exports.PRICE_OFFSET);
        }
    }
    return {
        amountOut: out,
        amountUsed,
        feeUsed,
        afterPrice: currentSqrtPrice,
        afterLiquity: liquity,
    };
}
exports.calculateSwapB2A = calculateSwapB2A;
/** @internal */
function maxAmountA(lowerSqrtPrice, upperSqrtPrice, liquity) {
    return liquity
        .div(lowerSqrtPrice)
        .toDP(0, decimal_js_1.Decimal.ROUND_DOWN)
        .sub(liquity.div(upperSqrtPrice).toDP(0, decimal_js_1.Decimal.ROUND_DOWN));
}
exports.maxAmountA = maxAmountA;
/** @internal */
function maxAmountB(lowerSqrtPrice, upperSqrtPrice, liquity) {
    return liquity
        .mul(upperSqrtPrice.sub(lowerSqrtPrice))
        .toDP(0, decimal_js_1.Decimal.ROUND_DOWN);
}
exports.maxAmountB = maxAmountB;
/** @internal */
function swapA2B(upperSqrtPrice, liquity, amountIn) {
    const afterSqrtPrice = liquity.div(amountIn.add(liquity.div(upperSqrtPrice)));
    const delta_increase = amountIn.add(liquity.div(upperSqrtPrice).toDP(0, decimal_js_1.Decimal.ROUND_DOWN));
    const out = liquity
        .mul(upperSqrtPrice)
        .toDP(0, decimal_js_1.Decimal.ROUND_DOWN)
        .sub(liquity.mul(liquity).div(delta_increase).toDP(0, decimal_js_1.Decimal.ROUND_DOWN));
    return { amountOut: out, afterSqrtPrice };
}
exports.swapA2B = swapA2B;
/** @internal */
function swapB2A(lowerSqrtPrice, liquity, amountIn) {
    const afterSqrtPrice = amountIn.div(liquity).add(lowerSqrtPrice);
    const delta_increase = amountIn.add(liquity.mul(lowerSqrtPrice).toDP(0, decimal_js_1.Decimal.ROUND_DOWN));
    const out = liquity
        .div(lowerSqrtPrice)
        .toDP(0, decimal_js_1.Decimal.ROUND_DOWN)
        .sub(liquity.mul(liquity).div(delta_increase).toDP(0, decimal_js_1.Decimal.ROUND_DOWN));
    return { amountOut: out, afterSqrtPrice };
}
exports.swapB2A = swapB2A;
/*
 * Convert the tick to ui price.
 * @param tick the tick.
 * @param baseDecimals the base token decimals.
 * @param quoteDecimals the quote token decimals
 * @return The ui price
 */
function tick2UiPrice(tick, baseDecimals, quoteDecimals) {
    return lamportPrice2uiPrice(tick2Price(tick), baseDecimals, quoteDecimals);
}
exports.tick2UiPrice = tick2UiPrice;
/*
 * Convert the ui price to tick.
 * @param price the ui price.
 * @param baseDecimals the base token decimals.
 * @param quoteDecimals the quote token decimals
 * @return The tick
 */
function uiPrice2Tick(price, baseDecimals, quoteDecimals) {
    return price2Tick(uiPrice2LamportPrice(price, baseDecimals, quoteDecimals));
}
exports.uiPrice2Tick = uiPrice2Tick;
/*
 * Convert the lamport price(with decimals) to ui price
 * @param price the lamport price
 * @param baseDecimals the base token decimals.
 * @param quoteDecimals the quote token decimals
 * @return The ui price
 */
function lamportPrice2uiPrice(price, baseDecimals, quoteDecimals) {
    const multiple = new decimal_js_1.Decimal(10).pow(baseDecimals - quoteDecimals);
    return price.mul(multiple);
}
exports.lamportPrice2uiPrice = lamportPrice2uiPrice;
/*
 * Convert the ui price to lamport price
 * @param price the lamport price
 * @param baseDecimals the base token decimals.
 * @param quoteDecimals the quote token decimals
 * @return The lamport price
 */
function uiPrice2LamportPrice(price, baseDecimals, quoteDecimals) {
    const multiple = new decimal_js_1.Decimal(10).pow(quoteDecimals - baseDecimals);
    return price.mul(multiple);
}
exports.uiPrice2LamportPrice = uiPrice2LamportPrice;
//# sourceMappingURL=tick.js.map