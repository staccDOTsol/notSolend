"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.calculateSlidTokenAmount = exports.calculateLiquityTable = exports.calculateLiquityOnlyB = exports.calculateLiquityOnlyA = exports.calculateTokenAmount = exports.calculateLiquity = void 0;
const tslib_1 = require("tslib");
const decimal_js_1 = tslib_1.__importDefault(require("decimal.js"));
const tiny_invariant_1 = tslib_1.__importDefault(require("tiny-invariant"));
const _1 = require(".");
/**
 * Calculate liquity and another token amount when current tick is in [tickLower, tickUpper]
 * @param tickLower The tick lower
 * @param tickUpper The tick upper
 * @param currentSqrtPrice The current sqrt price
 * @param desiredAmountSrc The src token amount
 * @param direct 0(desiredAmountSrc is TokenA), 1(desiredAmountSrc is TokenB)
 * @returns The liquity and dst token amount
 */
function calculateLiquity(tickLower, tickUpper, desiredAmountSrc, currentSqrtPrice, direct) {
    (0, tiny_invariant_1.default)(tickLower < tickUpper, "The tickLower must less than tickUpper");
    const lowerSqrtPrice = (0, _1.tick2SqrtPrice)(tickLower);
    const upperSqrtPrice = (0, _1.tick2SqrtPrice)(tickUpper);
    (0, tiny_invariant_1.default)(currentSqrtPrice.greaterThanOrEqualTo(lowerSqrtPrice) &&
        currentSqrtPrice.lessThanOrEqualTo(upperSqrtPrice), "The current price must in [lowerPrice,upperPrice]");
    const one = new decimal_js_1.default(1);
    if (direct === 0) {
        const deltaLiquity = desiredAmountSrc.div(one.div(currentSqrtPrice).sub(one.div(upperSqrtPrice)));
        const desiredAmountDst = deltaLiquity.mul(currentSqrtPrice.sub(lowerSqrtPrice));
        return { desiredAmountDst, deltaLiquity };
    }
    else {
        const deltaLiquity = desiredAmountSrc.div(currentSqrtPrice.sub(lowerSqrtPrice));
        const desiredAmountDst = deltaLiquity.mul(one.div(currentSqrtPrice).sub(one.div(upperSqrtPrice)));
        return { desiredAmountDst, deltaLiquity };
    }
}
exports.calculateLiquity = calculateLiquity;
/**
 * Calculate amount out of token A and token B by liquity
 * @param tickLower The tick lower
 * @param tickUpper The tick upper
 * @param currentSqrtPrice The current sqrt price
 * @param liquity The liquity amount
 * @returns The amount of token A and token B
 */
function calculateTokenAmount(tickLower, tickUpper, liquity, currentSqrtPrice) {
    const lowerSqrtPrice = (0, _1.tick2SqrtPrice)(tickLower);
    const upperSqrtPrice = (0, _1.tick2SqrtPrice)(tickUpper);
    if (currentSqrtPrice.lessThan(lowerSqrtPrice)) {
        return {
            amountA: liquity
                .div(lowerSqrtPrice)
                .sub(liquity.div(upperSqrtPrice))
                .toDecimalPlaces(0),
            amountB: new decimal_js_1.default(0),
        };
    }
    else if (currentSqrtPrice.greaterThan(upperSqrtPrice)) {
        return {
            amountA: new decimal_js_1.default(0),
            amountB: liquity
                .mul(upperSqrtPrice)
                .sub(liquity.mul(lowerSqrtPrice))
                .toDecimalPlaces(0),
        };
    }
    else {
        return {
            amountA: liquity
                .div(currentSqrtPrice)
                .sub(liquity.div(upperSqrtPrice))
                .toDecimalPlaces(0),
            amountB: liquity
                .mul(currentSqrtPrice)
                .sub(liquity.mul(lowerSqrtPrice))
                .toDecimalPlaces(0),
        };
    }
}
exports.calculateTokenAmount = calculateTokenAmount;
/**
 * Calculate liquity when current tick is less than tickLower
 * @param tickLower The tick lower
 * @param tickUpper The tick upper
 * @param desiredAmountA The desired amount of token A
 * @returns the liquity
 */
function calculateLiquityOnlyA(tickLower, tickUpper, desiredAmountA) {
    (0, tiny_invariant_1.default)(tickLower < tickUpper, "The tickLower must less than tickUpper");
    const lowerSqrtPrice = (0, _1.tick2SqrtPrice)(tickLower);
    const upperSqrtPrice = (0, _1.tick2SqrtPrice)(tickUpper);
    const one = new decimal_js_1.default(1);
    return desiredAmountA.div(one.div(lowerSqrtPrice).sub(one.div(upperSqrtPrice)));
}
exports.calculateLiquityOnlyA = calculateLiquityOnlyA;
/**
 * Calculate liquity when current tick is less than tickLower
 * @param tickLower The tick lower
 * @param tickUpper The tick upper
 * @returns The liquity
 */
function calculateLiquityOnlyB(tickLower, tickUpper, desiredAmountB) {
    (0, tiny_invariant_1.default)(tickLower < tickUpper, "The tickLower must less than tickUpper");
    const lowerSqrtPrice = (0, _1.tick2SqrtPrice)(tickLower);
    const upperSqrtPrice = (0, _1.tick2SqrtPrice)(tickUpper);
    return desiredAmountB.div(upperSqrtPrice.sub(lowerSqrtPrice));
}
exports.calculateLiquityOnlyB = calculateLiquityOnlyB;
/**
 * Calculate the liquitys table
 * @param ticks The tick array of token swap
 * @returns The min, max of liquity, and liquitys array
 */
function calculateLiquityTable(ticks) {
    let minLiquity = new decimal_js_1.default(0);
    let maxLiquity = new decimal_js_1.default(0);
    const liquitys = [];
    const liquity = {
        lowerTick: 0,
        upperTick: 0,
        amount: new decimal_js_1.default(0),
    };
    for (let i = 0; i < ticks.length; i++) {
        const tick = ticks[i];
        (0, tiny_invariant_1.default)(tick !== undefined);
        if (liquity.amount.equals(0)) {
            liquity.lowerTick = tick.tick;
            liquity.amount = tick.liquityNet;
            continue;
        }
        liquity.upperTick = tick.tick;
        minLiquity =
            liquity.amount.lessThan(minLiquity) || minLiquity.equals(0)
                ? liquity.amount
                : minLiquity;
        maxLiquity = liquity.amount.greaterThan(maxLiquity)
            ? liquity.amount
            : maxLiquity;
        liquitys.push({
            lowerTick: liquity.lowerTick,
            upperTick: liquity.upperTick,
            amount: liquity.amount,
        });
        liquity.amount = liquity.amount.add(tick.liquityNet);
        liquity.lowerTick = tick.tick;
    }
    return { maxLiquity, minLiquity, liquitys };
}
exports.calculateLiquityTable = calculateLiquityTable;
/**
 * Calculate max tokenAmount with sliding point.
 * @param liquity.
 */
function calculateSlidTokenAmount(tickLower, tickUpper, liquity, currentSqrtPrice, slid) {
    (0, tiny_invariant_1.default)(slid.lessThan(1) && slid.greaterThan(0), `Invalid slid:${slid.toString()}`);
    const maxSqrtPrice = currentSqrtPrice.mul(new decimal_js_1.default(1).add(slid).sqrt());
    const minSqrtPrice = currentSqrtPrice.mul(new decimal_js_1.default(1).sub(slid).sqrt());
    const constant = calculateTokenAmount(tickLower, tickUpper, liquity, currentSqrtPrice);
    const minRes = calculateTokenAmount(tickLower, tickUpper, liquity, minSqrtPrice);
    const maxRes = calculateTokenAmount(tickLower, tickUpper, liquity, maxSqrtPrice);
    return {
        maxAmountA: minRes.amountA,
        minAmountA: maxRes.amountA,
        maxAmountB: maxRes.amountB,
        minAmountB: minRes.amountB,
        amountA: constant.amountA,
        amountB: constant.amountB,
    };
}
exports.calculateSlidTokenAmount = calculateSlidTokenAmount;
//# sourceMappingURL=liquity.js.map