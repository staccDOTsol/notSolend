{"version":3,"file":"math.cjs.production.min.js","sources":["../src/utils.ts","../src/math/curve.ts","../src/amm/stable.ts","../src/amm/fees.ts","../src/amm/tokenswap-stable.ts","../src/amm/tokenswap-constant-product.ts","../src/fraction.ts"],"sourcesContent":["import JSBI from 'jsbi';\nimport Decimal from 'decimal.js';\n\nexport type SwapResult = {\n  priceImpact: Decimal;\n  fees: JSBI;\n  expectedOutputAmount: JSBI;\n};\n\nexport const ZERO = JSBI.BigInt(0);\nexport const ONE = JSBI.BigInt(1);\nexport const TWO = JSBI.BigInt(2);\n\nexport function abs(number: JSBI) {\n  if (JSBI.GE(number, ZERO)) {\n    return number;\n  }\n\n  return JSBI.unaryMinus(number);\n}\n\nexport function sumArray(numbers: JSBI[]) {\n  return numbers.reduce((prev, curr) => {\n    return JSBI.add(prev, curr);\n  }, ZERO);\n}\n\nexport function mulArray(numbers: JSBI[]) {\n  return numbers.reduce((prev, curr) => {\n    return JSBI.multiply(prev, curr);\n  }, ONE);\n}\n\nexport function ceilingDivision(dividend: JSBI, divisor: JSBI): [JSBI, JSBI] {\n  let quotient = JSBI.divide(dividend, divisor);\n  if (JSBI.equal(quotient, ZERO)) {\n    return [ZERO, ZERO];\n  }\n\n  let remainder = JSBI.remainder(dividend, divisor);\n  if (JSBI.greaterThan(remainder, ZERO)) {\n    quotient = JSBI.add(quotient, ONE);\n    divisor = JSBI.divide(dividend, quotient);\n    remainder = JSBI.remainder(dividend, quotient);\n    if (JSBI.greaterThan(remainder, ZERO)) {\n      divisor = JSBI.add(divisor, ONE);\n    }\n  }\n\n  return [quotient, divisor];\n}\n\nexport function toDecimal(input: JSBI, shift = 0) {\n  return new Decimal(input.toString()).div(new Decimal(10).pow(shift));\n}\n","import JSBI from 'jsbi';\nimport { abs, mulArray, ONE, sumArray, TWO, ZERO } from '../utils';\nimport Decimal from 'decimal.js';\n\nexport class Curve {\n  constructor(private numberOfCurrencies: JSBI, private amplificationFactor: JSBI, private targetPrices: JSBI[]) {}\n\n  public exchange(\n    tokenAmounts: JSBI[],\n    inputIndex: number,\n    outputIndex: number,\n    amount: JSBI,\n    minusOne: boolean = true,\n  ) {\n    if (tokenAmounts.length !== JSBI.toNumber(this.numberOfCurrencies)) {\n      throw new Error('Number of currencies does not match');\n    }\n\n    let xp = this.xp(tokenAmounts);\n    let dx = JSBI.multiply(amount, this.targetPrices[inputIndex]);\n    let x = JSBI.add(xp[inputIndex], dx);\n    let y = this.computeY(tokenAmounts, inputIndex, outputIndex, x);\n    let dy = JSBI.subtract(xp[outputIndex], y);\n\n    // This is a special condition on Curve stable algo. For TokenSwap, they don't seem to apply this minus one.\n    if (minusOne) {\n      dy = JSBI.subtract(dy, ONE);\n    }\n\n    return JSBI.divide(dy, this.targetPrices[outputIndex]);\n  }\n\n  public computeBaseY(tokenAmounts: JSBI[], inputIndex: number, outputIndex: number, amount: JSBI) {\n    let d = this.computeD(tokenAmounts);\n    let xp = this.xp(tokenAmounts);\n    let nn = JSBI.exponentiate(this.numberOfCurrencies, this.numberOfCurrencies);\n    let sum = sumArray(xp);\n    let product = mulArray(xp);\n    let k = JSBI.subtract(\n      JSBI.add(JSBI.multiply(JSBI.multiply(this.amplificationFactor, nn), sum), d),\n      JSBI.multiply(JSBI.multiply(this.amplificationFactor, d), nn),\n    );\n    let b = JSBI.multiply(JSBI.multiply(JSBI.multiply(this.amplificationFactor, nn), nn), product);\n    let c = JSBI.multiply(JSBI.multiply(nn, product), k);\n    let numerator = JSBI.add(b, JSBI.divide(c, xp[inputIndex]));\n    let denominator = JSBI.add(b, JSBI.divide(c, xp[outputIndex]));\n\n    // Convert to number since JSBI doesn't support log10\n    let inputFactor = Math.log10(JSBI.toNumber(this.targetPrices[inputIndex]));\n    let outputFactor = Math.log10(JSBI.toNumber(this.targetPrices[outputIndex]));\n    let factor = Math.abs(outputFactor - inputFactor);\n\n    if (inputFactor >= outputFactor) {\n      return JSBI.BigInt(\n        new Decimal(numerator.toString())\n          .mul(new Decimal(amount.toString()))\n          .div(new Decimal(denominator.toString()))\n          .mul(Math.pow(10, factor))\n          .floor()\n          .toString(),\n      );\n    } else {\n      return JSBI.BigInt(\n        new Decimal(numerator.toString())\n          .mul(new Decimal(amount.toString()))\n          .div(new Decimal(denominator.toString()))\n          .div(Math.pow(10, factor))\n          .floor()\n          .toString(),\n      );\n    }\n  }\n\n  private computeY(tokenAmounts: JSBI[], inputIndex: number, outputIndex: number, newTotalAmount: JSBI) {\n    let d = this.computeD(tokenAmounts);\n    let xx = this.xp(tokenAmounts);\n    xx[inputIndex] = newTotalAmount;\n    xx.splice(outputIndex, 1);\n\n    let ann = JSBI.multiply(this.amplificationFactor, this.numberOfCurrencies);\n    let c = d;\n\n    for (const y of xx) {\n      c = JSBI.divide(JSBI.multiply(c, d), JSBI.multiply(y, this.numberOfCurrencies));\n    }\n    c = JSBI.divide(JSBI.multiply(c, d), JSBI.multiply(this.numberOfCurrencies, ann));\n\n    let b = JSBI.subtract(JSBI.add(sumArray(xx), JSBI.divide(d, ann)), d);\n    let yPrev = ZERO;\n    let y = d;\n\n    while (JSBI.greaterThan(abs(JSBI.subtract(y, yPrev)), ONE)) {\n      yPrev = y;\n      y = JSBI.divide(JSBI.add(JSBI.exponentiate(y, TWO), c), JSBI.add(JSBI.multiply(TWO, y), b));\n    }\n\n    return y;\n  }\n\n  private computeD(tokenAmounts: JSBI[]) {\n    let dPrev = ZERO;\n    let xp = this.xp(tokenAmounts);\n    let sum = sumArray(xp);\n    let d = sum;\n    let ann = JSBI.multiply(this.amplificationFactor, this.numberOfCurrencies);\n\n    while (JSBI.greaterThan(abs(JSBI.subtract(d, dPrev)), ONE)) {\n      let dP = d;\n      for (const x of xp) {\n        dP = JSBI.divide(JSBI.multiply(dP, d), JSBI.multiply(this.numberOfCurrencies, x));\n      }\n      dPrev = d;\n      let numerator = JSBI.multiply(JSBI.add(JSBI.multiply(ann, sum), JSBI.multiply(dP, this.numberOfCurrencies)), d);\n      let denominator = JSBI.add(\n        JSBI.multiply(JSBI.subtract(ann, ONE), d),\n        JSBI.multiply(JSBI.add(this.numberOfCurrencies, ONE), dP),\n      );\n      d = JSBI.divide(numerator, denominator);\n    }\n\n    return d;\n  }\n\n  private xp(tokenAmounts: JSBI[]) {\n    return tokenAmounts.map((tokenAmount, index) => {\n      return JSBI.multiply(tokenAmount, this.targetPrices[index]);\n    });\n  }\n\n  setAmplificationFactor(amplificationFactor: JSBI) {\n    this.amplificationFactor = amplificationFactor;\n  }\n}\n","import JSBI from 'jsbi';\nimport { Curve } from '../math/curve';\nimport { SwapResult, toDecimal, ZERO } from '../utils';\nimport Decimal from 'decimal.js';\nimport { Fraction } from '..';\n\nexport class Stable {\n  private curve: Curve;\n\n  constructor(numberOfCurrencies: JSBI, amp: JSBI, private targetPrices: JSBI[], private traderFee: Fraction) {\n    this.curve = new Curve(numberOfCurrencies, amp, this.targetPrices);\n  }\n\n  public exchange(tokenAmounts: JSBI[], inputTradeAmount: JSBI, inputIndex: number, outputIndex: number): SwapResult {\n    let outputAmountWithoutFees = this.getOutputAmount(tokenAmounts, inputTradeAmount, inputIndex, outputIndex);\n    let fees = this.getFees(outputAmountWithoutFees);\n    let expectedOutputAmount = JSBI.subtract(outputAmountWithoutFees, fees);\n\n    return {\n      priceImpact: this.getPriceImpact(tokenAmounts, inputTradeAmount, expectedOutputAmount, inputIndex, outputIndex),\n      fees: fees,\n      expectedOutputAmount: expectedOutputAmount,\n    };\n  }\n\n  private getPriceImpact(\n    tokenAmounts: JSBI[],\n    inputTradeAmountJSBI: JSBI,\n    expectedOutputAmountJSBI: JSBI,\n    inputIndex: number,\n    outputIndex: number,\n  ): Decimal {\n    if (\n      JSBI.equal(inputTradeAmountJSBI, ZERO) ||\n      JSBI.equal(tokenAmounts[inputIndex], ZERO) ||\n      JSBI.equal(tokenAmounts[outputIndex], ZERO)\n    ) {\n      return new Decimal(0);\n    }\n\n    const noSlippageOutputAmount = toDecimal(\n      this.getOutputAmountWithNoSlippage(tokenAmounts, inputTradeAmountJSBI, inputIndex, outputIndex),\n    );\n    const expectedOutputAmount = toDecimal(expectedOutputAmountJSBI);\n    const impact = noSlippageOutputAmount.sub(expectedOutputAmount).div(noSlippageOutputAmount);\n\n    return impact;\n  }\n\n  private getFees(outputAmountWithoutFees: JSBI): JSBI {\n    return JSBI.equal(this.traderFee.numerator, ZERO)\n      ? ZERO\n      : JSBI.divide(JSBI.multiply(outputAmountWithoutFees, this.traderFee.numerator), this.traderFee.denominator);\n  }\n\n  private getOutputAmount(tokenAmounts: JSBI[], inputTradeAmount: JSBI, inputIndex: number, outputIndex: number): JSBI {\n    return this.curve.exchange(tokenAmounts, inputIndex, outputIndex, inputTradeAmount);\n  }\n\n  private getOutputAmountWithNoSlippage(\n    tokenAmounts: JSBI[],\n    inputTradeAmount: JSBI,\n    inputIndex: number,\n    outputIndex: number,\n  ): JSBI {\n    return this.curve.computeBaseY(tokenAmounts, inputIndex, outputIndex, inputTradeAmount);\n  }\n\n  setAmp(amp: JSBI) {\n    this.curve.setAmplificationFactor(amp);\n  }\n}\n","import JSBI from 'jsbi';\nimport { Fraction } from '../fraction';\nimport { ZERO, ONE } from '../utils';\n\n/** calculates fee amount given a fee fraction, returning one when fee is set but amount is zero */\nexport function calculateFeeAmount(amount: JSBI, fee: Fraction): JSBI {\n  if (JSBI.equal(fee.numerator, ZERO) || JSBI.equal(amount, ZERO)) {\n    return ZERO;\n  } else {\n    const feeAmount = JSBI.divide(JSBI.multiply(amount, fee.numerator), fee.denominator);\n    if (JSBI.equal(feeAmount, ZERO)) {\n      return ONE;\n    }\n    return feeAmount;\n  }\n}\n","import JSBI from 'jsbi';\nimport { Curve } from '../math/curve';\nimport { ONE, SwapResult, toDecimal, ZERO, TWO } from '../utils';\nimport Decimal from 'decimal.js';\nimport { Fraction } from '../fraction';\nimport { calculateFeeAmount } from './fees';\n\nexport class TokenSwapStable {\n  private curve: Curve;\n\n  constructor(amp: JSBI, private traderFee: Fraction, private ownerFee: Fraction) {\n    this.curve = new Curve(TWO, amp, [ONE, ONE]);\n  }\n\n  public exchange(tokenAmounts: JSBI[], inputTradeAmount: JSBI, outputIndex: number): SwapResult {\n    let inputIndex = outputIndex === 0 ? 1 : 0;\n    let expectedOutputAmount = this.getExpectedOutputAmount(tokenAmounts, inputTradeAmount, inputIndex, outputIndex);\n\n    return {\n      priceImpact: this.getPriceImpact(tokenAmounts, inputTradeAmount, expectedOutputAmount, inputIndex, outputIndex),\n      fees: this.getFees(inputTradeAmount),\n      expectedOutputAmount,\n    };\n  }\n\n  private getPriceImpact(\n    tokenAmounts: JSBI[],\n    inputTradeAmountJSBI: JSBI,\n    expectedOutputAmountJSBI: JSBI,\n    inputIndex: number,\n    outputIndex: number,\n  ): Decimal {\n    if (\n      JSBI.equal(inputTradeAmountJSBI, ZERO) ||\n      JSBI.equal(tokenAmounts[inputIndex], ZERO) ||\n      JSBI.equal(tokenAmounts[outputIndex], ZERO)\n    ) {\n      return new Decimal(0);\n    }\n\n    const noSlippageOutputAmount = toDecimal(\n      this.getExpectedOutputAmountWithNoSlippage(tokenAmounts, inputTradeAmountJSBI, inputIndex, outputIndex),\n    );\n\n    const expectedOutputAmount = toDecimal(expectedOutputAmountJSBI);\n    const impact = noSlippageOutputAmount.sub(expectedOutputAmount).div(noSlippageOutputAmount);\n\n    return impact;\n  }\n\n  private getFees(inputTradeAmount: JSBI): JSBI {\n    const tradingFee = calculateFeeAmount(inputTradeAmount, this.traderFee);\n    const ownerFee = calculateFeeAmount(inputTradeAmount, this.ownerFee);\n\n    return JSBI.add(tradingFee, ownerFee);\n  }\n\n  private getExpectedOutputAmount(\n    tokenAmounts: JSBI[],\n    inputTradeAmount: JSBI,\n    inputIndex: number,\n    outputIndex: number,\n  ): JSBI {\n    const inputTradeAmountLessFees = this.getInputAmountLessFees(inputTradeAmount);\n\n    return this.getOutputAmount(tokenAmounts, inputTradeAmountLessFees, inputIndex, outputIndex);\n  }\n\n  private getExpectedOutputAmountWithNoSlippage(\n    tokenAmounts: JSBI[],\n    inputTradeAmount: JSBI,\n    inputIndex: number,\n    outputIndex: number,\n  ): JSBI {\n    const inputTradeAmountLessFees = this.getInputAmountLessFees(inputTradeAmount);\n\n    return this.getOutputAmountWithNoSlippage(tokenAmounts, inputTradeAmountLessFees, inputIndex, outputIndex);\n  }\n\n  private getInputAmountLessFees(inputTradeAmount: JSBI): JSBI {\n    return JSBI.subtract(inputTradeAmount, this.getFees(inputTradeAmount));\n  }\n\n  private getOutputAmount(\n    tokenAmounts: JSBI[],\n    inputTradeAmountLessFees: JSBI,\n    inputIndex: number,\n    outputIndex: number,\n  ): JSBI {\n    return this.curve.exchange(tokenAmounts, inputIndex, outputIndex, inputTradeAmountLessFees, false);\n  }\n\n  private getOutputAmountWithNoSlippage(\n    tokenAmounts: JSBI[],\n    inputTradeAmountLessFees: JSBI,\n    inputIndex: number,\n    outputIndex: number,\n  ): JSBI {\n    return this.curve.computeBaseY(tokenAmounts, inputIndex, outputIndex, inputTradeAmountLessFees);\n  }\n}\n","import JSBI from 'jsbi';\nimport { SwapResult, toDecimal, ZERO, ceilingDivision } from '../utils';\nimport Decimal from 'decimal.js';\nimport { Fraction } from '..';\nimport { calculateFeeAmount } from './fees';\n\nexport class TokenSwapConstantProduct {\n  constructor(private traderFee: Fraction, private ownerFee: Fraction, private feesOnInput: boolean = true) {}\n\n  public exchange(tokenAmounts: JSBI[], inputTradeAmount: JSBI, outputIndex: number): SwapResult {\n    let inputIndex = outputIndex === 0 ? 1 : 0;\n    const newInputTradeAmount = this.feesOnInput ? this.getAmountLessFees(inputTradeAmount) : inputTradeAmount;\n\n    let expectedOutputAmount = this.getExpectedOutputAmount(tokenAmounts, newInputTradeAmount, inputIndex, outputIndex);\n\n    let fees = this.getFees(this.feesOnInput ? inputTradeAmount : expectedOutputAmount);\n\n    if (!this.feesOnInput) {\n      expectedOutputAmount = this.getAmountLessFees(expectedOutputAmount);\n    }\n\n    return {\n      priceImpact: this.getPriceImpact(\n        tokenAmounts,\n        newInputTradeAmount,\n        expectedOutputAmount,\n        inputIndex,\n        outputIndex,\n      ),\n      fees,\n      expectedOutputAmount,\n    };\n  }\n\n  private getPriceImpact(\n    tokenAmounts: JSBI[],\n    inputTradeAmountJSBI: JSBI,\n    expectedOutputAmountJSBI: JSBI,\n    inputIndex: number,\n    outputIndex: number,\n  ): Decimal {\n    if (\n      JSBI.equal(inputTradeAmountJSBI, ZERO) ||\n      JSBI.equal(tokenAmounts[inputIndex], ZERO) ||\n      JSBI.equal(tokenAmounts[outputIndex], ZERO)\n    ) {\n      return new Decimal(0);\n    }\n\n    const noSlippageOutputAmount = toDecimal(\n      this.getExpectedOutputAmountWithNoSlippage(tokenAmounts, inputTradeAmountJSBI, inputIndex, outputIndex),\n    );\n    const expectedOutputAmount = toDecimal(expectedOutputAmountJSBI);\n    const impact = noSlippageOutputAmount.sub(expectedOutputAmount).div(noSlippageOutputAmount);\n\n    return impact;\n  }\n\n  private getFees(inputTradeAmount: JSBI): JSBI {\n    const tradingFee = calculateFeeAmount(inputTradeAmount, this.traderFee);\n    const ownerFee = calculateFeeAmount(inputTradeAmount, this.ownerFee);\n\n    return JSBI.add(tradingFee, ownerFee);\n  }\n\n  private getExpectedOutputAmount(\n    tokenAmounts: JSBI[],\n    inputTradeAmount: JSBI,\n    inputIndex: number,\n    outputIndex: number,\n  ): JSBI {\n    return this.getOutputAmount(tokenAmounts, inputTradeAmount, inputIndex, outputIndex);\n  }\n\n  private getExpectedOutputAmountWithNoSlippage(\n    tokenAmounts: JSBI[],\n    inputTradeAmount: JSBI,\n    inputIndex: number,\n    outputIndex: number,\n  ): JSBI {\n    if (JSBI.equal(tokenAmounts[inputIndex], ZERO)) {\n      return tokenAmounts[outputIndex];\n    }\n\n    let expectedOutputAmountWithNoSlippage = JSBI.divide(\n      JSBI.multiply(inputTradeAmount, tokenAmounts[outputIndex]),\n      tokenAmounts[inputIndex],\n    );\n\n    if (this.feesOnInput) {\n      return expectedOutputAmountWithNoSlippage;\n    } else {\n      return this.getAmountLessFees(expectedOutputAmountWithNoSlippage);\n    }\n  }\n\n  private getAmountLessFees(tradeAmount: JSBI): JSBI {\n    return JSBI.subtract(tradeAmount, this.getFees(tradeAmount));\n  }\n\n  private getOutputAmount(tokenAmounts: JSBI[], inputTradeAmount: JSBI, inputIndex: number, outputIndex: number): JSBI {\n    const [poolInputAmount, poolOutputAmount] = [tokenAmounts[inputIndex], tokenAmounts[outputIndex]];\n\n    const invariant = this.getInvariant(tokenAmounts);\n\n    const [newPoolOutputAmount] = ceilingDivision(invariant, JSBI.add(poolInputAmount, inputTradeAmount));\n\n    return JSBI.subtract(poolOutputAmount, newPoolOutputAmount);\n  }\n\n  getInvariant(tokenAmounts: JSBI[]) {\n    return JSBI.multiply(tokenAmounts[0], tokenAmounts[1]);\n  }\n}\n","import JSBI from 'jsbi';\n\nexport class Fraction {\n  constructor(public numerator: JSBI, public denominator: JSBI) {}\n}\n\nexport const ZERO_FRACTION = new Fraction(JSBI.BigInt(0), JSBI.BigInt(1));\n"],"names":["ZERO","JSBI","BigInt","ONE","TWO","abs","number","GE","unaryMinus","sumArray","numbers","reduce","prev","curr","add","mulArray","multiply","ceilingDivision","dividend","divisor","quotient","divide","equal","remainder","greaterThan","toDecimal","input","shift","Decimal","toString","div","pow","Curve","numberOfCurrencies","amplificationFactor","targetPrices","this","_proto","prototype","exchange","tokenAmounts","inputIndex","outputIndex","amount","minusOne","length","toNumber","Error","xp","dx","x","y","computeY","dy","subtract","computeBaseY","d","computeD","nn","exponentiate","sum","product","k","b","c","numerator","denominator","inputFactor","Math","log10","outputFactor","factor","mul","floor","newTotalAmount","xx","splice","_step","ann","_iterator","_createForOfIteratorHelperLoose","done","value","yPrev","dPrev","_step2","dP","_iterator2","_this","map","tokenAmount","index","setAmplificationFactor","Stable","amp","traderFee","curve","inputTradeAmount","outputAmountWithoutFees","getOutputAmount","fees","getFees","expectedOutputAmount","priceImpact","getPriceImpact","inputTradeAmountJSBI","expectedOutputAmountJSBI","noSlippageOutputAmount","getOutputAmountWithNoSlippage","sub","setAmp","calculateFeeAmount","fee","feeAmount","TokenSwapStable","ownerFee","getExpectedOutputAmount","getExpectedOutputAmountWithNoSlippage","tradingFee","inputTradeAmountLessFees","getInputAmountLessFees","TokenSwapConstantProduct","feesOnInput","newInputTradeAmount","getAmountLessFees","expectedOutputAmountWithNoSlippage","tradeAmount","_ref","poolInputAmount","poolOutputAmount","_ceilingDivision","getInvariant","Fraction","ZERO_FRACTION"],"mappings":"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"}