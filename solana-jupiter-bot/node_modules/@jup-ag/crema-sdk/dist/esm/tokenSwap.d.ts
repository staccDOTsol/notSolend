import type { Provider } from "@saberhq/solana-contrib";
import { TransactionEnvelope } from "@saberhq/solana-contrib";
import { PublicKey } from "@solana/web3.js";
import Decimal from "decimal.js";
import type { Tick, TokenSwapAccount } from "./state";
export declare const INIT_KEY: PublicKey;
export declare const SWAP_B2A = 1;
export declare const SWAP_A2B = 0;
export declare const FIX_TOKEN_A = 0;
export declare const FIX_TOKEN_B = 1;
export interface PositionInfo {
    positionsKey: PublicKey;
    index: Decimal;
    positionId: PublicKey;
    lowerTick: number;
    upperTick: number;
    liquity: Decimal;
    feeGrowthInsideALast: Decimal;
    feeGrowthInsideBLast: Decimal;
    tokenAFee: Decimal;
    tokenBFee: Decimal;
}
export interface SwapPairInfo extends TokenSwapAccount {
    tokenADecimals: number;
    tokenBDecimals: number;
}
export interface PendingCreateSwapPair {
    swapKey: PublicKey;
    positionsKey: PublicKey;
    ticksKey: PublicKey;
    swapTokenA: PublicKey;
    swapTokenB: PublicKey;
    managerTokenA: PublicKey;
    managerTokenB: PublicKey;
    authority: PublicKey;
    tx: TransactionEnvelope;
}
export interface PendingMintPosition {
    positionId: PublicKey;
    positionAccount: PublicKey;
    positionsKey: PublicKey;
    tx: TransactionEnvelope;
}
/**
 * The token swap class
 */
export declare class TokenSwap {
    provider: Provider;
    programId: PublicKey;
    tokenSwapKey: PublicKey;
    authority: PublicKey;
    isLoaded: boolean;
    currentTick: number;
    tokenSwapInfo: SwapPairInfo;
    ticks: Tick[];
    positions: Map<string, PositionInfo>;
    positionsKeys: Map<PublicKey, number>;
    /**
     * The constructor of TokenSwap
     * @param programId The token swap program id
     * @param tokenSwapKey The token swap key
     */
    constructor(provider: Provider, programId: PublicKey, tokenSwapKey: PublicKey);
    /**
     * Load the token swap info
     */
    load(): Promise<TokenSwap>;
    /**
     * Fetch the swap list
     */
    static fetchSwapPairs(provider: Provider, programId: PublicKey): Promise<Array<TokenSwapAccount>>;
    static createTokenSwap({ provider, programId, tokenAMint, tokenBMint, manager, fee, managerFee, tickSpace, tickAccountSize, initializePrice, }: {
        provider: Provider;
        programId: PublicKey;
        tokenAMint: PublicKey;
        tokenBMint: PublicKey;
        manager: PublicKey;
        fee: Decimal;
        managerFee: Decimal;
        tickSpace: number;
        tickAccountSize: number;
        initializePrice: Decimal;
    }): Promise<PendingCreateSwapPair>;
    /**
     *
     * @param userTokenA The user address of token A
     * @param userTokenB The user address of token B
     * @param lowerTick The lower tick
     * @param upperTick The upper tick
     * @param liquity The liquity amount
     * @param maximumAmountA The maximum amount of Token A
     * @param maximumAmountB The maximum amount of Token B
     * @returns
     */
    mintPosition(userTokenA: PublicKey, userTokenB: PublicKey, lowerTick: number, upperTick: number, liquity: Decimal, maximumAmountA: Decimal, maximumAmountB: Decimal): Promise<PendingMintPosition>;
    /**
     * Mint a position and you can specified a fix token amount.
     * @param userTokenA The user address of token A
     * @param userTokenB The user address of token B
     * @param fixTokenType 0-FixTokenA 1-FixTokenB
     * @param lowerTick The lower tick
     * @param upperTick The upper tick
     * @param maximumAmountA The maximum amount of Token A
     * @param maximumAmountB The maximum amount of Token B
     * @returns
     */
    mintPositionFixToken(userTokenA: PublicKey, userTokenB: PublicKey, fixTokenType: number, lowerTick: number, upperTick: number, maximumAmountA: Decimal, maximumAmountB: Decimal): Promise<PendingMintPosition>;
    /**
     * Increase liquity on a exist position
     * @param positionId The position id (nft mint address)
     * @param userTokenA The user address of token A
     * @param userTokenB The user address of token B
     * @param liquity The liquity amount
     * @param maximumAmountA The maximum of token A
     * @param maximumAmountB The maximum of token B
     * @returns
     */
    increaseLiquity(positionId: PublicKey, userTokenA: PublicKey, userTokenB: PublicKey, liquity: Decimal, maximumAmountA: Decimal, maximumAmountB: Decimal, positionAccount?: PublicKey | null): Promise<TransactionEnvelope>;
    /**
     * Increase liquity on a exist position and you can specified a fix token amount.
     * @param positionId The position id (nft mint address)
     * @param userTokenA The user address of token A
     * @param userTokenB The user address of token B
     * @param fixTokenType The liquity amount
     * @param maximumAmountA The maximum of token A
     * @param maximumAmountB The maximum of token B
     * @returns
     */
    increaseLiquityFixToken(positionId: PublicKey, userTokenA: PublicKey, userTokenB: PublicKey, fixTokenType: number, maximumAmountA: Decimal, maximumAmountB: Decimal, positionAccount?: PublicKey | null): Promise<TransactionEnvelope>;
    /**
     * Decrease liquity, after decrease if liquity amount is zero the position will be remove
     * @param positionId The position id (nft mint address)
     * @param userTokenA The user address of token A
     * @param userTokenB The user address of token B
     * @param liquity The liquity amount
     * @param minimumAmountA The minimum amount of token A want recv
     * @param minimumAmountB The minimum amount of token b want recv
     * @returns
     */
    decreaseLiquity(positionId: PublicKey, userTokenA: PublicKey, userTokenB: PublicKey, liquity: Decimal, minimumAmountA: Decimal, minimumAmountB: Decimal, positionAccount?: PublicKey | null): Promise<TransactionEnvelope>;
    /**
     * Decrease liquity, after decrease if liquity amount is zero the position will be remove,
     * if user ATA not exist, it will be create.
     * @param positionId The position id (nft mint address)
     * @param liquity The liquity amount
     * @param minimumAmountA The minimum amount of token A want recv
     * @param minimumAmountB The minimum amount of token b want recv
     * @returns
     */
    decreaseLiquityAtomic(positionId: PublicKey, liquity: Decimal, minimumAmountA: Decimal, minimumAmountB: Decimal, positionAccount?: PublicKey | null): Promise<TransactionEnvelope>;
    /**
     *
     * @param userSource The token that user want swap out
     * @param userDestination The token that user want swap in
     * @param direct 0-A swap B, 1-B swap A
     * @param amountIn The amount in
     * @param minimumAmountOut The minimum amount out
     * @returns
     */
    swap(userSource: PublicKey, userDestination: PublicKey, direct: number, amountIn: Decimal, minimumAmountOut: Decimal): Promise<TransactionEnvelope>;
    /**
     * Token swap, if the dst ATA not exist it will create it.
     * @param direct 0-A swap B, 1-B swap A
     * @param amountIn The amount in
     * @param minimumAmountOut The minimum amount out
     * @returns
     */
    swapAtomic(direct: number, amountIn: Decimal, minimumAmountOut: Decimal): Promise<TransactionEnvelope>;
    simulateSwap(amountIn: Decimal, direction: number): Promise<void>;
    /**
     *
     * Claim fee from specified position
     * @param positionId The NFT token public key of position
     * @param userTokenA The user address of token A
     * @param userTokenB The user address of token B
     * @param positionAccount The token account of position NFT.
     * @returns
     */
    claim(positionId: PublicKey, userTokenA: PublicKey, userTokenB: PublicKey, positionAccount?: PublicKey | null): Promise<TransactionEnvelope>;
    /**
     *
     * Claim fee from specified position, if user ATA not exist it will create.
     * @param positionId The NFT token public key of position
     * @param positionAccount The token account of position NFT.
     * @returns
     */
    claimAtomic(positionId: PublicKey, positionAccount?: PublicKey | null): Promise<TransactionEnvelope>;
    /**
     * Claim the manager fee
     * @returns
     */
    managerClaim(): Promise<TransactionEnvelope>;
    /**
     * Add a positions account for token swap
     * @returns
     */
    addPositionsAccount(): Promise<TransactionEnvelope>;
    /**
     * Get user's positions
     * @param owner The owner of position
     * @returns The positions list
     */
    getUserPositions(owner?: PublicKey): Promise<PositionInfo[]>;
    /**
     * Calculate the liquity and token A amount, when the token swap currentTick < upperTick
     * @param tickLower The lower tick
     * @param tickUpper the upper tick
     * @param desiredAmountA The desired token A amount
     * @returns
     */
    calculateLiquityByTokenA(tickLower: number, tickUpper: number, desiredAmountA: Decimal, currentSqrtPrice?: Decimal): {
        desiredAmountB: Decimal;
        liquity: Decimal;
    };
    /**
     * Calculate the liquity and token B amount, when the token swap currentTick < upperTick
     * @param tickLower The lower tick
     * @param tickUpper the upper tick
     * @returns
     */
    calculateLiquityByTokenB(tickLower: number, tickUpper: number, desiredAmountB: Decimal, currentSqrtPrice?: Decimal): {
        desiredAmountA: Decimal;
        liquity: Decimal;
    };
    calculateLiquityWithSlid({ lowerTick, upperTick, amountA, amountB, slid, }: {
        lowerTick: number;
        upperTick: number;
        amountA: Decimal | null;
        amountB: Decimal | null;
        slid: Decimal;
    }): {
        liquity: Decimal;
        amountA: Decimal;
        amountB: Decimal;
        maximumAmountA: Decimal;
        maximumAmountB: Decimal;
        minimumAmountA: Decimal;
        minimumAmountB: Decimal;
    };
    /**
     * Calculate the position current value
     * @param positionId The position id
     * @returns The amount of token A and token B
     */
    calculatePositionValue(positionId: PublicKey): {
        liquity: Decimal;
        amountA: Decimal;
        amountB: Decimal;
    };
    calculatePositionValueWithSlid(positionId: PublicKey, percentage?: Decimal, slid?: Decimal): {
        liquity: Decimal;
        maxAmountA: Decimal;
        minAmountA: Decimal;
        maxAmountB: Decimal;
        minAmountB: Decimal;
        amountA: Decimal;
        amountB: Decimal;
    };
    /**
     * prepare calculate claim amount of token A and B
     * @param positionId The position id
     * @returns the amount of token A and B
     */
    preClaim(positionId: PublicKey): {
        amountA: Decimal;
        amountB: Decimal;
    };
    /**
     * Prepare calculate A swap B
     * @param amountIn The amount input of token A
     * @returns amountOut:The amount out of token B, amountUsed:The used of amountIn, afterPrice:The price after calculate, afterLiquity: The liquity after calculate
     */
    preSwapA(amountIn: Decimal): {
        amountOut: Decimal;
        amountUsed: Decimal;
        feeUsed: Decimal;
        afterLiquity: Decimal;
        impactA: Decimal;
        impactB: Decimal;
        transactionPriceA: Decimal;
        transactionPriceB: Decimal;
        afterPriceA: Decimal;
        afterPriceB: Decimal;
        revert: boolean;
        revertReason: string;
    };
    /**
     * Prepare calculate B swap A
     * @param amountIn The amount input of token B
     * @returns amountOut:The amount out of token A, amountUsed:The used of amountIn, afterPrice:The price after calculate, afterLiquity: The liquity after calculate
     */
    preSwapB(amountIn: Decimal): {
        amountOut: Decimal;
        amountUsed: Decimal;
        feeUsed: Decimal;
        afterLiquity: Decimal;
        impactA: Decimal;
        impactB: Decimal;
        transactionPriceA: Decimal;
        transactionPriceB: Decimal;
        afterPriceA: Decimal;
        afterPriceB: Decimal;
        revert: boolean;
        revertReason: string;
    };
    /**
     * Get nearest tick by price
     * @param price The price
     * @returns The tick
     */
    getNearestTickByPrice(price: Decimal): number;
    getPositionInfo(positionId: PublicKey): PositionInfo | undefined;
    choosePosition(): PublicKey | null;
    uiPrice(): Decimal;
    uiReversePrice(): Decimal;
    uiPrice2SwapPrice(price: Decimal): Decimal;
    uiPrice2SwapSqrtPrice(price: Decimal): Decimal;
    uiReversePrice2SwapPrice(price: Decimal): Decimal;
    uiReversePrice2SwapSqrtPrice(price: Decimal): Decimal;
    uiPrice2Tick(price: Decimal): number;
    uiReversePrice2Tick(price: Decimal): number;
    uiPrice2NearestTick(price: Decimal): number;
    uiReversePrice2NearestTick(price: Decimal): number;
    tick2UiPrice(tick: number): Decimal;
    tick2UiReversePrice(tick: number): Decimal;
    tokenALamports(amount: Decimal): Decimal;
    tokenBLamports(amount: Decimal): Decimal;
    tokenAAmount(lamport: Decimal): Decimal;
    tokenBAmount(lamport: Decimal): Decimal;
    calculateEffectivTick(lowerPrice: Decimal, upperPrice: Decimal): {
        lowerTick: number;
        upperTick: number;
    };
    calculateFixSideTokenAmount(lowerTick: number, upperTick: number, amountA: Decimal | null, amountB: Decimal | null, balanceA: Decimal, balanceB: Decimal, slid?: Decimal): {
        desiredAmountA: Decimal;
        desiredAmountB: Decimal;
        maxAmountA: Decimal;
        maxAmountB: Decimal;
        desiredDeltaLiquity: Decimal;
        maxDeltaLiquity: Decimal | undefined;
        fixTokenType: number;
        slidPrice: Decimal;
    };
    wrapSOL(amount: Decimal): Promise<TransactionEnvelope>;
    unwrapSOL(ataAddress: PublicKey, dest?: PublicKey): Promise<TransactionEnvelope>;
    private _checkUserPositionAccount;
}
//# sourceMappingURL=tokenSwap.d.ts.map