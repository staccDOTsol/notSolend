"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DecimalExt = void 0;
const tslib_1 = require("tslib");
const bn_js_1 = tslib_1.__importDefault(require("bn.js"));
const decimal_js_1 = tslib_1.__importDefault(require("decimal.js"));
const tiny_invariant_1 = tslib_1.__importDefault(require("tiny-invariant"));
decimal_js_1.default.config({
    precision: 64,
    rounding: decimal_js_1.default.ROUND_DOWN,
    toExpNeg: -64,
    toExpPos: 64,
});
const TEN = new decimal_js_1.default(10);
const P64 = new decimal_js_1.default(2).pow(64);
const MAX_INT64 = P64.div(2).sub(1);
const MIN_INT64 = P64.div(2).neg();
const MAX_UINT64 = P64.sub(1);
const MAX_INT128 = P64.pow(63).sub(1);
const MIN_INT128 = MAX_INT128.neg();
const MAX_UINT128 = P64.pow(64).sub(1);
const MAX_PRECISION = 40;
class DecimalExt {
    /**
     * New a Decimal from a int64 buffer
     * @param buffer The buffer
     * @param precision The pricision
     * @returns The Decimal value, the result will be div 10^precision
     */
    static from64Buffer(buffer, precision = 0) {
        (0, tiny_invariant_1.default)(buffer.length === 8, `Invalid buffer length: ${buffer.length}`);
        (0, tiny_invariant_1.default)(Math.abs(precision) < MAX_PRECISION, `Invalid precision: ${precision}`);
        (0, tiny_invariant_1.default)(buffer[7] !== undefined);
        if (buffer[7] >= 0x80) {
            const ss = [];
            for (const v of buffer) {
                ss.push(`00${Math.abs(~v & 0xff).toString(16)}`.slice(-2));
            }
            const bn = new bn_js_1.default(ss.join(""), 16, "le").add(new bn_js_1.default(1)).neg();
            return new decimal_js_1.default(bn.toString()).div(TEN.pow(precision));
        }
        return new decimal_js_1.default(new bn_js_1.default(buffer, "le").toString()).div(TEN.pow(precision));
    }
    /**
     * New a Decimal from a uint64 buffer
     * @param buffer The buffer
     * @param precision The precision
     * @returns The Decimal value, the result will be div 10^precision
     */
    static fromU64Buffer(buffer, precision = 0) {
        (0, tiny_invariant_1.default)(buffer.length === 8, `Invalid buffer length: ${buffer.length}`);
        (0, tiny_invariant_1.default)(Math.abs(precision) < MAX_PRECISION, `Invalid precision: ${precision}`);
        return new decimal_js_1.default(new bn_js_1.default(buffer, 16, "le").toString()).div(TEN.pow(precision));
    }
    /**
     * New a Decimal from a int128 buffer
     * @param buffer The buffer
     * @param precision The pricision
     * @returns The Decimal value, the result will be div 10^precision
     */
    static from128Buffer(buffer, precision = 0) {
        (0, tiny_invariant_1.default)(buffer.length === 16, `Invalid buffer length: ${buffer.length}`);
        (0, tiny_invariant_1.default)(Math.abs(precision) < MAX_PRECISION, `Invalid precision: ${precision}`);
        (0, tiny_invariant_1.default)(buffer[15] !== undefined);
        if (buffer[15] >= 0x80) {
            const ss = [];
            for (const v of buffer) {
                ss.push(`00${Math.abs(~v & 0xff).toString(16)}`.slice(-2));
            }
            const bn = new bn_js_1.default(ss.join(""), 16, "le").add(new bn_js_1.default(1)).neg();
            return new decimal_js_1.default(bn.toString()).div(TEN.pow(precision));
        }
        return new decimal_js_1.default(new bn_js_1.default(buffer, "le").toString()).div(TEN.pow(precision));
    }
    /**
     * New a Decimal from a uint128 buffer
     * @param buffer The buffer
     * @param precision The precision
     * @returns The Decimal value, the result will be div 10^precision
     */
    static fromU128Buffer(buffer, precision = 0) {
        (0, tiny_invariant_1.default)(buffer.length === 16, `Invalid buffer length: ${buffer.length}`);
        (0, tiny_invariant_1.default)(Math.abs(precision) < MAX_PRECISION, `Invalid precision: ${precision}`);
        return new decimal_js_1.default(new bn_js_1.default(buffer, "le").toString()).div(TEN.pow(precision));
    }
    /**
     * Convert a Decimal value to int64 buffer
     * @param v The Decimal value
     * @param precision The precision
     * @returns The buffer, the result will be mul 10^precision
     */
    static to64Buffer(v, precision = 0) {
        (0, tiny_invariant_1.default)(Math.abs(precision) < MAX_PRECISION, `Invalid precision: ${precision}`);
        v = v.mul(TEN.pow(precision)).round();
        (0, tiny_invariant_1.default)(v.greaterThanOrEqualTo(MIN_INT64) && v.lessThanOrEqualTo(MAX_INT64), `Invalid v: ${v.toString()} to int128 buffer with precision: ${precision}`);
        const bn = new bn_js_1.default(v.toString());
        if (bn.isNeg()) {
            const buffer = bn.add(new bn_js_1.default(1)).toArrayLike(Buffer, "le", 8);
            buffer.forEach(function (item, index, input) {
                input[index] = ~item & 0xff;
            });
            return buffer;
        }
        else {
            return bn.toArrayLike(Buffer, "le", 8);
        }
    }
    /**
     * Convert a Decimal value to uint64 buffer
     * @param v The Decimal value
     * @param precision The precision
     * @returns The buffer, the result will be mul 10^precision
     */
    static toU64Buffer(v, precision = 0) {
        (0, tiny_invariant_1.default)(Math.abs(precision) < MAX_PRECISION, `Invalid precision: ${precision}`);
        v = v.mul(TEN.pow(precision)).round();
        (0, tiny_invariant_1.default)(v.greaterThanOrEqualTo(0) && v.lessThanOrEqualTo(MAX_UINT64), `Invalid v: ${v.toString()} to uint64 buffer with precision: ${precision}`);
        return new bn_js_1.default(v.toString()).toArrayLike(Buffer, "le", 8);
    }
    /**
     * Convert a Decimal value to int128 buffer
     * @param v The Decimal value
     * @param precision The precision
     * @returns The buffer, the result will be mul 10^precision
     */
    static to128Buffer(v, precision = 0) {
        (0, tiny_invariant_1.default)(Math.abs(precision) < MAX_PRECISION, `Invalid precision: ${precision}`);
        v = v.mul(TEN.pow(precision)).round();
        (0, tiny_invariant_1.default)(v.greaterThanOrEqualTo(MIN_INT128) && v.lessThanOrEqualTo(MAX_INT128), `Invalid v: ${v.toString()} to int128 buffer with precision: ${precision}`);
        const bn = new bn_js_1.default(v.toString());
        if (bn.isNeg()) {
            const buffer = bn.add(new bn_js_1.default(1)).toArrayLike(Buffer, "le", 16);
            buffer.forEach(function (item, index, input) {
                input[index] = ~item & 0xff;
            });
            return buffer;
        }
        else {
            return bn.toArrayLike(Buffer, "le", 16);
        }
    }
    /**
     * Convert a Decimal value to uint128 buffer
     * @param v The Decimal value
     * @param precision The precision
     * @returns The buffer, the result will be mul 10^precision
     */
    static toU128Buffer(v, precision = 0) {
        (0, tiny_invariant_1.default)(Math.abs(precision) < MAX_PRECISION, `Invalid precision: ${precision}`);
        v = v.mul(TEN.pow(precision)).round();
        (0, tiny_invariant_1.default)(v.greaterThanOrEqualTo(0) && v.lessThanOrEqualTo(MAX_UINT128), `Invalid v: ${v.toString()} to int128 buffer with precision: ${precision}`);
        return new bn_js_1.default(v.toString()).toArrayLike(Buffer, "le", 16);
    }
}
exports.DecimalExt = DecimalExt;
//# sourceMappingURL=decimalExt.js.map