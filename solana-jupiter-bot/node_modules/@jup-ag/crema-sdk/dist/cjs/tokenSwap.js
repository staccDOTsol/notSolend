"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TokenSwap = exports.FIX_TOKEN_B = exports.FIX_TOKEN_A = exports.SWAP_A2B = exports.SWAP_B2A = exports.INIT_KEY = void 0;
const tslib_1 = require("tslib");
const solana_contrib_1 = require("@saberhq/solana-contrib");
const token_utils_1 = require("@saberhq/token-utils");
const spl_token_v2_1 = require("@solana/spl-token-v2");
const web3_js_1 = require("@solana/web3.js");
const bn_js_1 = tslib_1.__importDefault(require("bn.js"));
const bs58 = tslib_1.__importStar(require("bs58"));
const decimal_js_1 = tslib_1.__importDefault(require("decimal.js"));
const tiny_invariant_1 = tslib_1.__importDefault(require("tiny-invariant"));
const instructions_1 = require("./instructions");
const depositFixToken_1 = require("./instructions/depositFixToken");
const math_1 = require("./math");
const state_1 = require("./state");
const token_1 = require("./util/token");
exports.INIT_KEY = new web3_js_1.PublicKey("11111111111111111111111111111111");
exports.SWAP_B2A = 1;
exports.SWAP_A2B = 0;
exports.FIX_TOKEN_A = 0;
exports.FIX_TOKEN_B = 1;
decimal_js_1.default.config({
    precision: 64,
    rounding: decimal_js_1.default.ROUND_HALF_DOWN,
    toExpNeg: -64,
    toExpPos: 64,
});
/**
 * The token swap class
 */
class TokenSwap {
    /**
     * The constructor of TokenSwap
     * @param programId The token swap program id
     * @param tokenSwapKey The token swap key
     */
    constructor(provider, programId, tokenSwapKey) {
        this.programId = exports.INIT_KEY;
        this.tokenSwapKey = exports.INIT_KEY;
        this.authority = exports.INIT_KEY;
        this.isLoaded = false;
        this.currentTick = 0;
        this.tokenSwapInfo = {
            tokenSwapKey: exports.INIT_KEY,
            accountType: 0,
            version: 0,
            isInitialized: 0,
            nonce: 0,
            tokenProgramId: spl_token_v2_1.TOKEN_PROGRAM_ID,
            manager: exports.INIT_KEY,
            managerTokenA: exports.INIT_KEY,
            managerTokenB: exports.INIT_KEY,
            swapTokenA: exports.INIT_KEY,
            swapTokenB: exports.INIT_KEY,
            tokenAMint: exports.INIT_KEY,
            tokenBMint: exports.INIT_KEY,
            ticksKey: exports.INIT_KEY,
            positionsKey: exports.INIT_KEY,
            curveType: 0,
            fee: new decimal_js_1.default(0),
            managerFee: new decimal_js_1.default(0),
            tickSpace: 0,
            currentSqrtPrice: new decimal_js_1.default(0),
            currentLiquity: new decimal_js_1.default(0),
            feeGrowthGlobal0: new decimal_js_1.default(0),
            feeGrowthGlobal1: new decimal_js_1.default(0),
            managerFeeA: new decimal_js_1.default(0),
            managerFeeB: new decimal_js_1.default(0),
            tokenADecimals: 0,
            tokenBDecimals: 0,
        };
        this.ticks = [];
        this.provider = provider;
        this.tokenSwapKey = tokenSwapKey;
        this.programId = programId;
        this.positions = new Map();
        this.positionsKeys = new Map();
    }
    /**
     * Load the token swap info
     */
    async load() {
        const config = {
            encoding: "base64",
            filters: [
                {
                    memcmp: {
                        offset: 1,
                        bytes: this.tokenSwapKey.toBase58(),
                    },
                },
            ],
        };
        const accounts = await this.provider.connection.getProgramAccounts(this.programId, config);
        accounts.map((item) => {
            if ((0, state_1.isTokenSwapAccount)(item.account)) {
                const info = (0, state_1.parseTokenSwapAccount)(item.pubkey, item.account);
                (0, tiny_invariant_1.default)((info === null || info === void 0 ? void 0 : info.data) !== undefined, "The token swap account parse failed");
                this.tokenSwapInfo = {
                    ...info.data,
                    tokenADecimals: this.tokenSwapInfo.tokenADecimals,
                    tokenBDecimals: this.tokenSwapInfo.tokenBDecimals,
                };
            }
            else if ((0, state_1.isTicksAccount)(item.account)) {
                const info = (0, state_1.parseTicksAccount)(item.pubkey, item.account);
                (0, tiny_invariant_1.default)((info === null || info === void 0 ? void 0 : info.data) !== undefined, "The tick account parse failed");
                this.ticks = info.data.ticks;
            }
            else if ((0, state_1.isPositionsAccount)(item.account)) {
                const info = (0, state_1.parsePositionsAccount)(item.pubkey, item.account);
                (0, tiny_invariant_1.default)((info === null || info === void 0 ? void 0 : info.data) !== undefined, "The position account data parse failed");
                this.positionsKeys.set(item.pubkey, info.data.positions.length);
                for (let i = 0; i < info.data.positions.length; i++) {
                    const p = info.data.positions[i];
                    (0, tiny_invariant_1.default)(p !== undefined);
                    this.positions.set(p.nftTokenId.toBase58(), {
                        positionsKey: item.pubkey,
                        index: new decimal_js_1.default(i),
                        positionId: p.nftTokenId,
                        lowerTick: p.lowerTick,
                        upperTick: p.upperTick,
                        liquity: p.liquity,
                        feeGrowthInsideALast: p.feeGrowthInsideALast,
                        feeGrowthInsideBLast: p.feeGrowthInsideBLast,
                        tokenAFee: p.tokenAFee,
                        tokenBFee: p.tokenBFee,
                    });
                }
            }
            else {
                console.log("the account:%s length:%d unkown", item.pubkey.toString(), item.account.data.length);
            }
        });
        if (this.authority.toString() === exports.INIT_KEY.toString()) {
            const [authority] = await web3_js_1.PublicKey.findProgramAddress([this.tokenSwapKey.toBuffer()], this.programId);
            this.authority = authority;
        }
        if (!this.isLoaded) {
            const tokenASupply = await this.provider.connection.getTokenSupply(this.tokenSwapInfo.tokenAMint);
            const tokenBSupply = await this.provider.connection.getTokenSupply(this.tokenSwapInfo.tokenBMint);
            this.tokenSwapInfo.tokenADecimals = tokenASupply.value.decimals;
            this.tokenSwapInfo.tokenBDecimals = tokenBSupply.value.decimals;
        }
        this.isLoaded = true;
        this.currentTick = (0, math_1.sqrtPrice2Tick)(this.tokenSwapInfo.currentSqrtPrice);
        return this;
    }
    /**
     * Fetch the swap list
     */
    static async fetchSwapPairs(provider, programId) {
        const config = {
            filters: [
                {
                    memcmp: {
                        offset: 33,
                        bytes: bs58.encode(new bn_js_1.default(0).toArrayLike(Buffer, "le", 1)),
                    },
                },
                {
                    dataSize: state_1.TOKEN_SWAP_ACCOUNT_SIZE,
                },
            ],
        };
        const accounts = await provider.connection.getProgramAccounts(programId, config);
        const list = [];
        accounts.forEach((v) => {
            if ((0, state_1.isTokenSwapAccount)(v.account)) {
                const info = (0, state_1.parseTokenSwapAccount)(v.pubkey, v.account);
                (0, tiny_invariant_1.default)((info === null || info === void 0 ? void 0 : info.data) !== undefined, "The token swap account parse failed");
                list.push(info.data);
            }
        });
        return list;
    }
    static async createTokenSwap({ provider, programId, tokenAMint, tokenBMint, manager, fee, managerFee, tickSpace, tickAccountSize, initializePrice, }) {
        // generate account create instruction that token swap need
        const instructions = [];
        const swapAccount = web3_js_1.Keypair.generate();
        const ticksAccount = web3_js_1.Keypair.generate();
        const positionsAccount = web3_js_1.Keypair.generate();
        const [authority, nonce] = await web3_js_1.PublicKey.findProgramAddress([swapAccount.publicKey.toBuffer()], programId);
        const ticksAccountLamports = await provider.connection.getMinimumBalanceForRentExemption(tickAccountSize);
        const positionsAccountLarports = await provider.connection.getMinimumBalanceForRentExemption(state_1.POSITIONS_ACCOUNT_SIZE);
        const swapAccountLamports = await provider.connection.getMinimumBalanceForRentExemption(state_1.TOKEN_SWAP_ACCOUNT_SIZE);
        // generate create token swap authority token account instruction
        const swapTokenA = await (0, token_utils_1.getATAAddress)({
            mint: tokenAMint,
            owner: authority,
        });
        const swapTokenB = await (0, token_utils_1.getATAAddress)({
            mint: tokenBMint,
            owner: authority,
        });
        instructions.push(web3_js_1.SystemProgram.createAccount({
            fromPubkey: provider.wallet.publicKey,
            newAccountPubkey: swapAccount.publicKey,
            lamports: swapAccountLamports,
            space: state_1.TOKEN_SWAP_ACCOUNT_SIZE,
            programId: programId,
        }), web3_js_1.SystemProgram.createAccount({
            fromPubkey: provider.wallet.publicKey,
            newAccountPubkey: ticksAccount.publicKey,
            lamports: ticksAccountLamports,
            space: tickAccountSize,
            programId: programId,
        }), web3_js_1.SystemProgram.createAccount({
            fromPubkey: provider.wallet.publicKey,
            newAccountPubkey: positionsAccount.publicKey,
            lamports: positionsAccountLarports,
            space: state_1.POSITIONS_ACCOUNT_SIZE,
            programId: programId,
        }));
        // generate create token swap authority token account instruction
        instructions.push((0, token_utils_1.createATAInstruction)({
            address: swapTokenA,
            mint: tokenAMint,
            owner: authority,
            payer: provider.wallet.publicKey,
        }), (0, token_utils_1.createATAInstruction)({
            address: swapTokenB,
            mint: tokenBMint,
            owner: authority,
            payer: provider.wallet.publicKey,
        }));
        // generate token swap initialize instruction
        const currentSqrtPrice = initializePrice.sqrt();
        const managerTokenA = await (0, token_utils_1.getATAAddress)({
            mint: tokenAMint,
            owner: manager,
        });
        const managerTokenB = await (0, token_utils_1.getATAAddress)({
            mint: tokenBMint,
            owner: manager,
        });
        const curveType = 0;
        instructions.push((0, instructions_1.initializeInstruction)(programId, swapAccount.publicKey, authority, manager, managerTokenA, managerTokenB, swapTokenA, swapTokenB, ticksAccount.publicKey, positionsAccount.publicKey, nonce, curveType, fee, managerFee, tickSpace, currentSqrtPrice));
        return {
            swapKey: swapAccount.publicKey,
            positionsKey: positionsAccount.publicKey,
            ticksKey: ticksAccount.publicKey,
            swapTokenA,
            swapTokenB,
            managerTokenA,
            managerTokenB,
            authority,
            tx: new solana_contrib_1.TransactionEnvelope(provider, instructions, [
                swapAccount,
                ticksAccount,
                positionsAccount,
            ]),
        };
    }
    /**
     *
     * @param userTokenA The user address of token A
     * @param userTokenB The user address of token B
     * @param lowerTick The lower tick
     * @param upperTick The upper tick
     * @param liquity The liquity amount
     * @param maximumAmountA The maximum amount of Token A
     * @param maximumAmountB The maximum amount of Token B
     * @returns
     */
    async mintPosition(userTokenA, userTokenB, lowerTick, upperTick, liquity, maximumAmountA, maximumAmountB) {
        if (this.isLoaded) {
            await this.load();
        }
        (0, tiny_invariant_1.default)(lowerTick < upperTick, "The lowerTick must be less than upperTick");
        const instructions = [];
        // Generate create position nft token instructions
        const positionNftMint = web3_js_1.Keypair.generate();
        const positionAccount = await (0, token_utils_1.getATAAddress)({
            mint: positionNftMint.publicKey,
            owner: this.provider.wallet.publicKey,
        });
        const nftMintInstructions = await (0, token_utils_1.createMintInstructions)(this.provider, this.authority, positionNftMint.publicKey, 0);
        instructions.push(...nftMintInstructions);
        instructions.push((0, token_utils_1.createATAInstruction)({
            address: positionAccount,
            mint: positionNftMint.publicKey,
            owner: this.provider.wallet.publicKey,
            payer: this.provider.wallet.publicKey,
        }));
        const positionsKey = this.choosePosition();
        (0, tiny_invariant_1.default)(positionsKey !== null, "The position account space if full");
        // Generate mint positon instruction
        instructions.push((0, instructions_1.depositAllTokenTypesInstruction)(this.programId, this.tokenSwapKey, this.authority, this.provider.wallet.publicKey, userTokenA, userTokenB, this.tokenSwapInfo.swapTokenA, this.tokenSwapInfo.swapTokenB, positionNftMint.publicKey, positionAccount, this.tokenSwapInfo.ticksKey, positionsKey, 0, lowerTick, upperTick, liquity, maximumAmountA, maximumAmountB, new decimal_js_1.default(0)));
        if (this.tokenSwapInfo.tokenAMint.equals(spl_token_v2_1.NATIVE_MINT) &&
            maximumAmountA.greaterThan(0)) {
            const wrapSOLInstructions = await this.wrapSOL(maximumAmountA);
            instructions.unshift(...wrapSOLInstructions.instructions);
            const unwrapSOLInstructions = await this.unwrapSOL(userTokenA);
            instructions.push(...unwrapSOLInstructions.instructions);
        }
        if (this.tokenSwapInfo.tokenBMint.equals(spl_token_v2_1.NATIVE_MINT) &&
            maximumAmountB.greaterThan(0)) {
            const wrapSOLInstructions = await this.wrapSOL(maximumAmountB);
            instructions.unshift(...wrapSOLInstructions.instructions);
            const unwrapSOLInstructions = await this.unwrapSOL(userTokenB);
            instructions.push(...unwrapSOLInstructions.instructions);
        }
        return {
            positionId: positionNftMint.publicKey,
            positionAccount,
            positionsKey,
            tx: new solana_contrib_1.TransactionEnvelope(this.provider, instructions, [
                positionNftMint,
            ]),
        };
    }
    /**
     * Mint a position and you can specified a fix token amount.
     * @param userTokenA The user address of token A
     * @param userTokenB The user address of token B
     * @param fixTokenType 0-FixTokenA 1-FixTokenB
     * @param lowerTick The lower tick
     * @param upperTick The upper tick
     * @param maximumAmountA The maximum amount of Token A
     * @param maximumAmountB The maximum amount of Token B
     * @returns
     */
    async mintPositionFixToken(userTokenA, userTokenB, fixTokenType, lowerTick, upperTick, maximumAmountA, maximumAmountB) {
        if (this.isLoaded) {
            await this.load();
        }
        (0, tiny_invariant_1.default)(lowerTick < upperTick, "The lowerTick must be less than upperTick");
        const instructions = [];
        // Generate create position nft token instructions
        const positionNftMint = web3_js_1.Keypair.generate();
        const positionAccount = await (0, token_utils_1.getATAAddress)({
            mint: positionNftMint.publicKey,
            owner: this.provider.wallet.publicKey,
        });
        const nftMintInstructions = await (0, token_utils_1.createMintInstructions)(this.provider, this.authority, positionNftMint.publicKey, 0);
        instructions.push(...nftMintInstructions);
        instructions.push((0, token_utils_1.createATAInstruction)({
            address: positionAccount,
            mint: positionNftMint.publicKey,
            owner: this.provider.wallet.publicKey,
            payer: this.provider.wallet.publicKey,
        }));
        const positionsKey = this.choosePosition();
        (0, tiny_invariant_1.default)(positionsKey !== null, "The position account space if full");
        // Generate mint positon instruction
        instructions.push((0, depositFixToken_1.depositFixTokenInstruction)(this.programId, this.tokenSwapKey, this.authority, this.provider.wallet.publicKey, userTokenA, userTokenB, this.tokenSwapInfo.swapTokenA, this.tokenSwapInfo.swapTokenB, positionNftMint.publicKey, positionAccount, this.tokenSwapInfo.ticksKey, positionsKey, 0, fixTokenType, lowerTick, upperTick, maximumAmountA, maximumAmountB, new decimal_js_1.default(0)));
        if (this.tokenSwapInfo.tokenAMint.equals(spl_token_v2_1.NATIVE_MINT) &&
            maximumAmountA.greaterThan(0)) {
            const wrapSOLInstructions = await this.wrapSOL(maximumAmountA);
            instructions.unshift(...wrapSOLInstructions.instructions);
            const unwrapSOLInstructions = await this.unwrapSOL(userTokenA);
            instructions.push(...unwrapSOLInstructions.instructions);
        }
        if (this.tokenSwapInfo.tokenBMint.equals(spl_token_v2_1.NATIVE_MINT) &&
            maximumAmountB.greaterThan(0)) {
            const wrapSOLInstructions = await this.wrapSOL(maximumAmountB);
            instructions.unshift(...wrapSOLInstructions.instructions);
            const unwrapSOLInstructions = await this.unwrapSOL(userTokenB);
            instructions.push(...unwrapSOLInstructions.instructions);
        }
        return {
            positionId: positionNftMint.publicKey,
            positionAccount,
            positionsKey,
            tx: new solana_contrib_1.TransactionEnvelope(this.provider, instructions, [
                positionNftMint,
            ]),
        };
    }
    /**
     * Increase liquity on a exist position
     * @param positionId The position id (nft mint address)
     * @param userTokenA The user address of token A
     * @param userTokenB The user address of token B
     * @param liquity The liquity amount
     * @param maximumAmountA The maximum of token A
     * @param maximumAmountB The maximum of token B
     * @returns
     */
    async increaseLiquity(positionId, userTokenA, userTokenB, liquity, maximumAmountA, maximumAmountB, positionAccount = null) {
        if (!this.isLoaded) {
            await this.load();
        }
        const position = await this._checkUserPositionAccount(positionId, positionAccount);
        const tx = new solana_contrib_1.TransactionEnvelope(this.provider, [
            (0, instructions_1.depositAllTokenTypesInstruction)(this.programId, this.tokenSwapKey, this.authority, this.provider.wallet.publicKey, userTokenA, userTokenB, this.tokenSwapInfo.swapTokenA, this.tokenSwapInfo.swapTokenB, positionId, position.positionAccount, this.tokenSwapInfo.ticksKey, position.positionInfo.positionsKey, 1, position.positionInfo.lowerTick, position.positionInfo.upperTick, liquity, maximumAmountA, maximumAmountB, position.positionInfo.index),
        ]);
        if (this.tokenSwapInfo.tokenAMint.equals(spl_token_v2_1.NATIVE_MINT) &&
            maximumAmountA.greaterThan(0)) {
            const wrapSOLInstructions = await this.wrapSOL(maximumAmountA);
            tx.instructions.unshift(...wrapSOLInstructions.instructions);
            const unwrapSOLInstructions = await this.unwrapSOL(userTokenA);
            tx.instructions.push(...unwrapSOLInstructions.instructions);
        }
        if (this.tokenSwapInfo.tokenBMint.equals(spl_token_v2_1.NATIVE_MINT) &&
            maximumAmountB.greaterThan(0)) {
            const wrapSOLInstructions = await this.wrapSOL(maximumAmountB);
            tx.instructions.unshift(...wrapSOLInstructions.instructions);
            const unwrapSOLInstructions = await this.unwrapSOL(userTokenB);
            tx.instructions.push(...unwrapSOLInstructions.instructions);
        }
        return tx;
    }
    /**
     * Increase liquity on a exist position and you can specified a fix token amount.
     * @param positionId The position id (nft mint address)
     * @param userTokenA The user address of token A
     * @param userTokenB The user address of token B
     * @param fixTokenType The liquity amount
     * @param maximumAmountA The maximum of token A
     * @param maximumAmountB The maximum of token B
     * @returns
     */
    async increaseLiquityFixToken(positionId, userTokenA, userTokenB, fixTokenType, maximumAmountA, maximumAmountB, positionAccount = null) {
        if (!this.isLoaded) {
            await this.load();
        }
        const position = await this._checkUserPositionAccount(positionId, positionAccount);
        const tx = new solana_contrib_1.TransactionEnvelope(this.provider, [
            (0, depositFixToken_1.depositFixTokenInstruction)(this.programId, this.tokenSwapKey, this.authority, this.provider.wallet.publicKey, userTokenA, userTokenB, this.tokenSwapInfo.swapTokenA, this.tokenSwapInfo.swapTokenB, positionId, position.positionAccount, this.tokenSwapInfo.ticksKey, position.positionInfo.positionsKey, 1, fixTokenType, position.positionInfo.lowerTick, position.positionInfo.upperTick, maximumAmountA, maximumAmountB, position.positionInfo.index),
        ]);
        if (this.tokenSwapInfo.tokenAMint.equals(spl_token_v2_1.NATIVE_MINT) &&
            maximumAmountA.greaterThan(0)) {
            const wrapSOLInstructions = await this.wrapSOL(maximumAmountA);
            tx.instructions.unshift(...wrapSOLInstructions.instructions);
            const unwrapSOLInstructions = await this.unwrapSOL(userTokenA);
            tx.instructions.push(...unwrapSOLInstructions.instructions);
        }
        if (this.tokenSwapInfo.tokenBMint.equals(spl_token_v2_1.NATIVE_MINT) &&
            maximumAmountB.greaterThan(0)) {
            const wrapSOLInstructions = await this.wrapSOL(maximumAmountB);
            tx.instructions.unshift(...wrapSOLInstructions.instructions);
            const unwrapSOLInstructions = await this.unwrapSOL(userTokenB);
            tx.instructions.push(...unwrapSOLInstructions.instructions);
        }
        return tx;
    }
    /**
     * Decrease liquity, after decrease if liquity amount is zero the position will be remove
     * @param positionId The position id (nft mint address)
     * @param userTokenA The user address of token A
     * @param userTokenB The user address of token B
     * @param liquity The liquity amount
     * @param minimumAmountA The minimum amount of token A want recv
     * @param minimumAmountB The minimum amount of token b want recv
     * @returns
     */
    async decreaseLiquity(positionId, userTokenA, userTokenB, liquity, minimumAmountA, minimumAmountB, positionAccount = null) {
        if (!this.isLoaded) {
            await this.load();
        }
        const position = await this._checkUserPositionAccount(positionId, positionAccount);
        // Create withdrawAllTokenTypes instruction
        const tx = new solana_contrib_1.TransactionEnvelope(this.provider, [
            (0, instructions_1.withdrawAllTokenTypesInstruction)(this.programId, this.tokenSwapKey, this.authority, this.provider.wallet.publicKey, this.tokenSwapInfo.swapTokenA, this.tokenSwapInfo.swapTokenB, userTokenA, userTokenB, positionId, position.positionAccount, this.tokenSwapInfo.ticksKey, position.positionInfo.positionsKey, liquity, minimumAmountA, minimumAmountB, position.positionInfo.index),
        ]);
        if (this.tokenSwapInfo.tokenAMint.equals(spl_token_v2_1.NATIVE_MINT)) {
            const unwrapSOLTx = await this.unwrapSOL(userTokenA);
            tx.instructions.push(...unwrapSOLTx.instructions);
        }
        if (this.tokenSwapInfo.tokenBMint.equals(spl_token_v2_1.NATIVE_MINT)) {
            const unwrapSOLTx = await this.unwrapSOL(userTokenB);
            tx.instructions.push(...unwrapSOLTx.instructions);
        }
        return tx;
    }
    /**
     * Decrease liquity, after decrease if liquity amount is zero the position will be remove,
     * if user ATA not exist, it will be create.
     * @param positionId The position id (nft mint address)
     * @param liquity The liquity amount
     * @param minimumAmountA The minimum amount of token A want recv
     * @param minimumAmountB The minimum amount of token b want recv
     * @returns
     */
    async decreaseLiquityAtomic(positionId, liquity, minimumAmountA, minimumAmountB, positionAccount = null) {
        const { address: tokenAATA, instruction: tokenAATAInstruction } = await (0, token_utils_1.getOrCreateATA)({
            provider: this.provider,
            mint: this.tokenSwapInfo.tokenAMint,
            owner: this.provider.wallet.publicKey,
            payer: this.provider.wallet.publicKey,
        });
        const { address: tokenBATA, instruction: tokenBATAInstruction } = await (0, token_utils_1.getOrCreateATA)({
            provider: this.provider,
            mint: this.tokenSwapInfo.tokenBMint,
            owner: this.provider.wallet.publicKey,
            payer: this.provider.wallet.publicKey,
        });
        const instructions = [];
        if (tokenAATAInstruction !== null) {
            instructions.push(tokenAATAInstruction);
        }
        if (tokenBATAInstruction !== null) {
            instructions.push(tokenBATAInstruction);
        }
        const tx = await this.decreaseLiquity(positionId, tokenAATA, tokenBATA, liquity, minimumAmountA, minimumAmountB, positionAccount);
        tx.instructions.unshift(...instructions);
        return tx;
    }
    /**
     *
     * @param userSource The token that user want swap out
     * @param userDestination The token that user want swap in
     * @param direct 0-A swap B, 1-B swap A
     * @param amountIn The amount in
     * @param minimumAmountOut The minimum amount out
     * @returns
     */
    async swap(userSource, userDestination, direct, amountIn, minimumAmountOut) {
        if (!this.isLoaded) {
            await this.load();
        }
        const { swapSrc, swapDst } = direct === exports.SWAP_A2B
            ? {
                swapSrc: this.tokenSwapInfo.swapTokenA,
                swapDst: this.tokenSwapInfo.swapTokenB,
            }
            : {
                swapSrc: this.tokenSwapInfo.swapTokenB,
                swapDst: this.tokenSwapInfo.swapTokenA,
            };
        const tx = new solana_contrib_1.TransactionEnvelope(this.provider, [
            (0, instructions_1.swapInstruction)(this.programId, this.tokenSwapKey, this.authority, this.provider.wallet.publicKey, userSource, userDestination, swapSrc, swapDst, this.tokenSwapInfo.ticksKey, amountIn, minimumAmountOut),
        ]);
        if (this.tokenSwapInfo.tokenAMint.equals(spl_token_v2_1.NATIVE_MINT)) {
            if (direct === exports.SWAP_A2B) {
                const wrapSOLTx = await this.wrapSOL(amountIn);
                tx.instructions.unshift(...wrapSOLTx.instructions);
                const unwrapSOLTx = await this.unwrapSOL(userSource);
                tx.instructions.push(...unwrapSOLTx.instructions);
            }
            else {
                const unwrapSOLTx = await this.unwrapSOL(userDestination);
                tx.instructions.push(...unwrapSOLTx.instructions);
            }
        }
        if (this.tokenSwapInfo.tokenBMint.equals(spl_token_v2_1.NATIVE_MINT)) {
            if (direct === exports.SWAP_A2B) {
                const unwrapSOLTx = await this.unwrapSOL(userDestination);
                tx.instructions.push(...unwrapSOLTx.instructions);
            }
            else {
                const wrapSOLTx = await this.wrapSOL(amountIn);
                tx.instructions.unshift(...wrapSOLTx.instructions);
                const unwrapSOLTx = await this.unwrapSOL(userSource);
                tx.instructions.push(...unwrapSOLTx.instructions);
            }
        }
        return tx;
    }
    /**
     * Token swap, if the dst ATA not exist it will create it.
     * @param direct 0-A swap B, 1-B swap A
     * @param amountIn The amount in
     * @param minimumAmountOut The minimum amount out
     * @returns
     */
    async swapAtomic(direct, amountIn, minimumAmountOut) {
        const { srcMint, dstMint } = direct === exports.SWAP_A2B
            ? {
                srcMint: this.tokenSwapInfo.tokenAMint,
                dstMint: this.tokenSwapInfo.tokenBMint,
            }
            : {
                srcMint: this.tokenSwapInfo.tokenBMint,
                dstMint: this.tokenSwapInfo.tokenAMint,
            };
        const { address: dstATA, instruction: dstATAInstruction } = await (0, token_utils_1.getOrCreateATA)({
            provider: this.provider,
            mint: dstMint,
            owner: this.provider.wallet.publicKey,
            payer: this.provider.wallet.publicKey,
        });
        const instructions = [];
        if (dstATAInstruction !== null) {
            instructions.push(dstATAInstruction);
        }
        const srcATA = await (0, token_utils_1.getATAAddress)({
            mint: srcMint,
            owner: this.provider.wallet.publicKey,
        });
        const swapTx = await this.swap(srcATA, dstATA, direct, amountIn, minimumAmountOut);
        swapTx.instructions.unshift(...instructions);
        return swapTx;
    }
    async simulateSwap(amountIn, direction) {
        if (!this.isLoaded) {
            await this.load();
        }
        const tx = new solana_contrib_1.TransactionEnvelope(this.provider, [
            (0, instructions_1.simulateSwapInstruction)(this.programId, this.tokenSwapKey, this.tokenSwapInfo.ticksKey, amountIn, direction),
        ]);
        const res = await tx.simulate();
        console.log(res);
    }
    /**
     *
     * Claim fee from specified position
     * @param positionId The NFT token public key of position
     * @param userTokenA The user address of token A
     * @param userTokenB The user address of token B
     * @param positionAccount The token account of position NFT.
     * @returns
     */
    async claim(positionId, userTokenA, userTokenB, positionAccount = null) {
        if (!this.isLoaded) {
            await this.load();
        }
        const position = await this._checkUserPositionAccount(positionId, positionAccount);
        const tx = new solana_contrib_1.TransactionEnvelope(this.provider, [
            (0, instructions_1.claimInstruction)(this.programId, this.tokenSwapKey, this.authority, this.provider.wallet.publicKey, this.tokenSwapInfo.swapTokenA, this.tokenSwapInfo.swapTokenB, userTokenA, userTokenB, positionId, position.positionAccount, this.tokenSwapInfo.ticksKey, position.positionInfo.positionsKey, position.positionInfo.index),
        ]);
        if (this.tokenSwapInfo.tokenAMint.equals(spl_token_v2_1.NATIVE_MINT)) {
            const unwrapSOLTx = await this.unwrapSOL(userTokenA);
            tx.instructions.push(...unwrapSOLTx.instructions);
        }
        if (this.tokenSwapInfo.tokenBMint.equals(spl_token_v2_1.NATIVE_MINT)) {
            const unwrapSOLTx = await this.unwrapSOL(userTokenB);
            tx.instructions.push(...unwrapSOLTx.instructions);
        }
        return tx;
    }
    /**
     *
     * Claim fee from specified position, if user ATA not exist it will create.
     * @param positionId The NFT token public key of position
     * @param positionAccount The token account of position NFT.
     * @returns
     */
    async claimAtomic(positionId, positionAccount = null) {
        const { address: tokenAATA, instruction: tokenAATAInstruction } = await (0, token_utils_1.getOrCreateATA)({
            provider: this.provider,
            mint: this.tokenSwapInfo.tokenAMint,
            owner: this.provider.wallet.publicKey,
            payer: this.provider.wallet.publicKey,
        });
        const { address: tokenBATA, instruction: tokenBATAInstruction } = await (0, token_utils_1.getOrCreateATA)({
            provider: this.provider,
            mint: this.tokenSwapInfo.tokenBMint,
            owner: this.provider.wallet.publicKey,
            payer: this.provider.wallet.publicKey,
        });
        const instructions = [];
        if (tokenAATAInstruction !== null) {
            instructions.push(tokenAATAInstruction);
        }
        if (tokenBATAInstruction !== null) {
            instructions.push(tokenBATAInstruction);
        }
        const tx = await this.claim(positionId, tokenAATA, tokenBATA, positionAccount);
        tx.instructions.unshift(...instructions);
        return tx;
    }
    /**
     * Claim the manager fee
     * @returns
     */
    async managerClaim() {
        if (!this.isLoaded) {
            await this.load();
        }
        const tx = new solana_contrib_1.TransactionEnvelope(this.provider, [
            (0, instructions_1.managerClaimInstruction)(this.programId, this.tokenSwapKey, this.authority, this.provider.wallet.publicKey, this.tokenSwapInfo.swapTokenA, this.tokenSwapInfo.swapTokenB, this.tokenSwapInfo.managerTokenA, this.tokenSwapInfo.managerTokenB),
        ]);
        if (this.tokenSwapInfo.tokenAMint.equals(spl_token_v2_1.NATIVE_MINT)) {
            const unwrapSOLTx = await this.unwrapSOL(this.tokenSwapInfo.managerTokenA, this.tokenSwapInfo.manager);
            tx.instructions.push(...unwrapSOLTx.instructions);
        }
        if (this.tokenSwapInfo.tokenBMint.equals(spl_token_v2_1.NATIVE_MINT)) {
            const unwrapSOLTx = await this.unwrapSOL(this.tokenSwapInfo.managerTokenB, this.tokenSwapInfo.manager);
            tx.instructions.push(...unwrapSOLTx.instructions);
        }
        return tx;
    }
    /**
     * Add a positions account for token swap
     * @returns
     */
    async addPositionsAccount() {
        if (!this.isLoaded) {
            await this.load();
        }
        const positionsAccount = web3_js_1.Keypair.generate();
        const lamports = await this.provider.connection.getMinimumBalanceForRentExemption(state_1.POSITIONS_ACCOUNT_SIZE);
        return new solana_contrib_1.TransactionEnvelope(this.provider, [
            web3_js_1.SystemProgram.createAccount({
                fromPubkey: this.provider.wallet.publicKey,
                newAccountPubkey: positionsAccount.publicKey,
                lamports,
                space: state_1.POSITIONS_ACCOUNT_SIZE,
                programId: this.programId,
            }),
            (0, instructions_1.addUserPositionInstruction)(this.programId, this.authority, positionsAccount.publicKey),
        ]);
    }
    /**
     * Get user's positions
     * @param owner The owner of position
     * @returns The positions list
     */
    async getUserPositions(owner = this.provider.wallet.publicKey) {
        (0, tiny_invariant_1.default)(this.isLoaded, "The token swap not load");
        const tokenAccounts = await (0, token_1.getTokenAccounts)(this.provider.connection, owner);
        const positions = [];
        tokenAccounts.forEach((v) => {
            const position = this.positions.get(v.mint.toBase58());
            if (position !== undefined) {
                positions.push(position);
            }
        });
        return positions;
    }
    /**
     * Calculate the liquity and token A amount, when the token swap currentTick < upperTick
     * @param tickLower The lower tick
     * @param tickUpper the upper tick
     * @param desiredAmountA The desired token A amount
     * @returns
     */
    calculateLiquityByTokenA(tickLower, tickUpper, desiredAmountA, currentSqrtPrice = this.tokenSwapInfo.currentSqrtPrice) {
        const currentTick = (0, math_1.sqrtPrice2Tick)(currentSqrtPrice);
        (0, tiny_invariant_1.default)(this.isLoaded, "The token swap not load");
        (0, tiny_invariant_1.default)(currentTick <= tickUpper, "when current price greater than upper price, can only add token b");
        if (currentTick < tickLower) {
            return {
                desiredAmountB: new decimal_js_1.default(0),
                liquity: (0, math_1.calculateLiquityOnlyA)(tickLower, tickUpper, desiredAmountA),
            };
        }
        else {
            const res = (0, math_1.calculateLiquity)(tickLower, tickUpper, desiredAmountA, currentSqrtPrice, 0);
            return {
                desiredAmountB: res.desiredAmountDst,
                liquity: res.deltaLiquity,
            };
        }
    }
    /**
     * Calculate the liquity and token B amount, when the token swap currentTick < upperTick
     * @param tickLower The lower tick
     * @param tickUpper the upper tick
     * @returns
     */
    calculateLiquityByTokenB(tickLower, tickUpper, desiredAmountB, currentSqrtPrice = this.tokenSwapInfo.currentSqrtPrice) {
        const currentTick = (0, math_1.sqrtPrice2Tick)(currentSqrtPrice);
        (0, tiny_invariant_1.default)(this.isLoaded, "The token swap not load");
        (0, tiny_invariant_1.default)(currentTick >= tickLower, "when current price less than lower price, can only add token a");
        if (currentTick > tickUpper) {
            return {
                desiredAmountA: new decimal_js_1.default(0),
                liquity: (0, math_1.calculateLiquityOnlyB)(tickLower, tickUpper, desiredAmountB),
            };
        }
        else {
            const res = (0, math_1.calculateLiquity)(tickLower, tickUpper, desiredAmountB, currentSqrtPrice, 1);
            return {
                desiredAmountA: res.desiredAmountDst,
                liquity: res.deltaLiquity,
            };
        }
    }
    // Calculate the liquity with price slid
    calculateLiquityWithSlid({ lowerTick, upperTick, amountA = null, amountB = null, slid = new decimal_js_1.default(0.01), }) {
        (0, tiny_invariant_1.default)(amountA !== null || amountB !== null, "the amout is null");
        let liquity = new decimal_js_1.default(0);
        const lamportA = amountA !== null ? this.tokenALamports(amountA).toDecimalPlaces(0) : null;
        const lamportB = amountB !== null ? this.tokenBLamports(amountB).toDecimalPlaces(0) : null;
        if (lamportA !== null) {
            liquity = this.calculateLiquityByTokenA(lowerTick, upperTick, lamportA).liquity;
        }
        else {
            (0, tiny_invariant_1.default)(lamportB !== null);
            liquity = this.calculateLiquityByTokenB(lowerTick, upperTick, lamportB).liquity;
        }
        const slidRes = (0, math_1.calculateSlidTokenAmount)(lowerTick, upperTick, liquity, this.tokenSwapInfo.currentSqrtPrice, slid);
        return {
            liquity: liquity.toDecimalPlaces(0),
            amountA: slidRes.amountA.toDecimalPlaces(0),
            amountB: slidRes.amountB.toDecimalPlaces(0),
            maximumAmountA: slidRes.maxAmountA.toDecimalPlaces(0),
            maximumAmountB: slidRes.maxAmountB.toDecimalPlaces(0),
            minimumAmountA: slidRes.minAmountA.toDecimalPlaces(0),
            minimumAmountB: slidRes.minAmountB.toDecimalPlaces(0),
        };
    }
    /**
     * Calculate the position current value
     * @param positionId The position id
     * @returns The amount of token A and token B
     */
    calculatePositionValue(positionId) {
        (0, tiny_invariant_1.default)(this.isLoaded, "The token swap not load");
        const positionInfo = this.getPositionInfo(positionId);
        (0, tiny_invariant_1.default)(positionInfo !== undefined, `The position:${positionId.toBase58()} not found`);
        const { amountA, amountB } = (0, math_1.calculateTokenAmount)(positionInfo.lowerTick, positionInfo.upperTick, positionInfo.liquity, this.tokenSwapInfo.currentSqrtPrice);
        return {
            liquity: positionInfo.liquity,
            amountA,
            amountB,
        };
    }
    calculatePositionValueWithSlid(positionId, percentage = new decimal_js_1.default(1), slid = new decimal_js_1.default(0.01)) {
        (0, tiny_invariant_1.default)(this.isLoaded, "The token swap not load");
        (0, tiny_invariant_1.default)(percentage.greaterThan(0) && percentage.lessThanOrEqualTo(1), `Invalid pencentage:${percentage.toString()}`);
        const positionInfo = this.getPositionInfo(positionId);
        (0, tiny_invariant_1.default)(positionInfo !== undefined, `The position:${positionId.toBase58()} not found`);
        const liquity = positionInfo.liquity.mul(percentage).toDecimalPlaces(0);
        const res = (0, math_1.calculateSlidTokenAmount)(positionInfo.lowerTick, positionInfo.upperTick, liquity, this.tokenSwapInfo.currentSqrtPrice, slid);
        return {
            liquity,
            ...res,
        };
    }
    /**
     * prepare calculate claim amount of token A and B
     * @param positionId The position id
     * @returns the amount of token A and B
     */
    preClaim(positionId) {
        (0, tiny_invariant_1.default)(this.isLoaded, "The token swap not load");
        const positionInfo = this.getPositionInfo(positionId);
        (0, tiny_invariant_1.default)(positionInfo !== undefined, `The position:${positionId.toBase58()} not found`);
        let lowerTick = null;
        let upperTick = null;
        for (let i = 0; i < this.ticks.length; i++) {
            const tick = this.ticks[i];
            (0, tiny_invariant_1.default)(tick !== undefined);
            if (tick.tick === positionInfo.lowerTick) {
                lowerTick = tick;
            }
            if (tick.tick === positionInfo.upperTick) {
                upperTick = tick;
            }
        }
        (0, tiny_invariant_1.default)(lowerTick !== null, `The position lower tick:${positionInfo.lowerTick} not found`);
        (0, tiny_invariant_1.default)(upperTick !== null, `The position upper tick:${positionInfo.upperTick} not found`);
        let lowerFeeOutSideA = new decimal_js_1.default(0);
        let lowerFeeOutSideB = new decimal_js_1.default(0);
        let upperFeeOutSideA = new decimal_js_1.default(0);
        let upperFeeOutSideB = new decimal_js_1.default(0);
        const currentSqrtPrice = this.tokenSwapInfo.currentSqrtPrice;
        if (lowerTick.tickPrice.lessThan(currentSqrtPrice)) {
            lowerFeeOutSideA = lowerTick.feeGrowthOutside0;
            lowerFeeOutSideB = lowerTick.feeGrowthOutside1;
        }
        else {
            lowerFeeOutSideA = this.tokenSwapInfo.feeGrowthGlobal0.sub(lowerTick.feeGrowthOutside0);
            lowerFeeOutSideB = this.tokenSwapInfo.feeGrowthGlobal1.sub(lowerTick.feeGrowthOutside1);
        }
        if (upperTick.tickPrice.lessThan(currentSqrtPrice)) {
            upperFeeOutSideA = this.tokenSwapInfo.feeGrowthGlobal0.sub(upperTick.feeGrowthOutside0);
            upperFeeOutSideB = this.tokenSwapInfo.feeGrowthGlobal1.sub(upperTick.feeGrowthOutside1);
        }
        else {
            upperFeeOutSideA = upperTick.feeGrowthOutside0;
            upperFeeOutSideB = upperTick.feeGrowthOutside1;
        }
        return {
            amountA: this.tokenSwapInfo.feeGrowthGlobal0
                .sub(lowerFeeOutSideA)
                .sub(upperFeeOutSideA)
                .sub(positionInfo.feeGrowthInsideALast)
                .mul(positionInfo.liquity)
                .add(positionInfo.tokenAFee),
            amountB: this.tokenSwapInfo.feeGrowthGlobal1
                .sub(lowerFeeOutSideB)
                .sub(upperFeeOutSideB)
                .sub(positionInfo.feeGrowthInsideBLast)
                .mul(positionInfo.liquity)
                .add(positionInfo.tokenBFee),
        };
    }
    /**
     * Prepare calculate A swap B
     * @param amountIn The amount input of token A
     * @returns amountOut:The amount out of token B, amountUsed:The used of amountIn, afterPrice:The price after calculate, afterLiquity: The liquity after calculate
     */
    preSwapA(amountIn) {
        (0, tiny_invariant_1.default)(this.isLoaded, "The token swap not load");
        const res = (0, math_1.calculateSwapA2B)(this.ticks, this.tokenSwapInfo.currentSqrtPrice, this.tokenSwapInfo.fee, this.tokenSwapInfo.currentLiquity, amountIn);
        const currentPriceA = this.uiPrice();
        const currentPriceB = this.uiReversePrice();
        const transactionPriceA = res.amountOut.div(res.amountUsed);
        const transactionPriceB = res.amountUsed.div(res.amountOut);
        const impactA = transactionPriceA
            .sub(currentPriceA)
            .div(currentPriceA)
            .abs();
        const impactB = transactionPriceB
            .sub(currentPriceB)
            .div(currentPriceB)
            .abs();
        const afterPriceA = res.afterPrice.pow(2);
        const afterPriceB = new decimal_js_1.default(1).div(afterPriceA);
        const revert = res.amountUsed.lessThan(amountIn);
        const revertReason = revert ? "Insufficient liquidity" : "";
        return {
            amountOut: res.amountOut,
            amountUsed: res.amountUsed,
            feeUsed: res.feeUsed,
            afterPriceA,
            afterPriceB,
            afterLiquity: res.afterLiquity,
            impactA,
            impactB,
            transactionPriceA,
            transactionPriceB,
            revert,
            revertReason,
        };
    }
    /**
     * Prepare calculate B swap A
     * @param amountIn The amount input of token B
     * @returns amountOut:The amount out of token A, amountUsed:The used of amountIn, afterPrice:The price after calculate, afterLiquity: The liquity after calculate
     */
    preSwapB(amountIn) {
        (0, tiny_invariant_1.default)(this.isLoaded, "The token swap not load");
        const res = (0, math_1.calculateSwapB2A)(this.ticks, this.tokenSwapInfo.currentSqrtPrice, this.tokenSwapInfo.fee, this.tokenSwapInfo.currentLiquity, amountIn);
        const currentPriceA = this.tokenSwapInfo.currentSqrtPrice.pow(2);
        const currentPriceB = new decimal_js_1.default(1).div(currentPriceA);
        const transactionPriceA = res.amountUsed.div(res.amountOut);
        const transactionPriceB = res.amountOut.div(res.amountUsed);
        const impactA = transactionPriceA
            .sub(currentPriceA)
            .div(currentPriceA)
            .abs();
        const impactB = transactionPriceB
            .sub(currentPriceB)
            .div(currentPriceB)
            .abs();
        const afterPriceA = res.afterPrice.pow(2);
        const afterPriceB = new decimal_js_1.default(1).div(afterPriceA);
        const revert = res.amountUsed.lessThan(amountIn);
        const revertReason = revert ? "Insufficient liquidity" : "";
        return {
            amountOut: res.amountOut,
            amountUsed: res.amountUsed,
            feeUsed: res.feeUsed,
            afterLiquity: res.afterLiquity,
            impactA,
            impactB,
            transactionPriceA,
            transactionPriceB,
            afterPriceA,
            afterPriceB,
            revert,
            revertReason,
        };
    }
    /**
     * Get nearest tick by price
     * @param price The price
     * @returns The tick
     */
    getNearestTickByPrice(price) {
        (0, tiny_invariant_1.default)(this.isLoaded, "The token swap not load");
        return (0, math_1.getNearestTickByPrice)(price, this.tokenSwapInfo.tickSpace);
    }
    /* @internal */
    getPositionInfo(positionId) {
        (0, tiny_invariant_1.default)(this.isLoaded, "The token swap not load");
        return this.positions.get(positionId.toBase58());
    }
    /* @internal */
    choosePosition() {
        (0, tiny_invariant_1.default)(this.isLoaded, "The token swap not load");
        for (const [key, val] of this.positionsKeys) {
            if (val < state_1.MAX_ACCOUNT_POSITION_LENGTH) {
                return key;
            }
        }
        return null;
    }
    uiPrice() {
        (0, tiny_invariant_1.default)(this.isLoaded, "The token swap not load");
        return (0, math_1.lamportPrice2uiPrice)(this.tokenSwapInfo.currentSqrtPrice.pow(2), this.tokenSwapInfo.tokenADecimals, this.tokenSwapInfo.tokenBDecimals);
    }
    uiReversePrice() {
        (0, tiny_invariant_1.default)(this.isLoaded, "The token swap not load");
        return new decimal_js_1.default(1).div(this.uiPrice());
    }
    uiPrice2SwapPrice(price) {
        (0, tiny_invariant_1.default)(this.isLoaded, "The token swap not load");
        return (0, math_1.uiPrice2LamportPrice)(price, this.tokenSwapInfo.tokenADecimals, this.tokenSwapInfo.tokenBDecimals);
    }
    uiPrice2SwapSqrtPrice(price) {
        (0, tiny_invariant_1.default)(this.isLoaded, "The token swap not load");
        return (0, math_1.uiPrice2LamportPrice)(price, this.tokenSwapInfo.tokenADecimals, this.tokenSwapInfo.tokenBDecimals).sqrt();
    }
    uiReversePrice2SwapPrice(price) {
        (0, tiny_invariant_1.default)(this.isLoaded, "The token swap not load");
        return (0, math_1.uiPrice2LamportPrice)(new decimal_js_1.default(1).div(price), this.tokenSwapInfo.tokenADecimals, this.tokenSwapInfo.tokenBDecimals);
    }
    uiReversePrice2SwapSqrtPrice(price) {
        (0, tiny_invariant_1.default)(this.isLoaded, "The token swap not load");
        return (0, math_1.uiPrice2LamportPrice)(new decimal_js_1.default(1).div(price), this.tokenSwapInfo.tokenADecimals, this.tokenSwapInfo.tokenBDecimals).sqrt();
    }
    uiPrice2Tick(price) {
        (0, tiny_invariant_1.default)(this.isLoaded, "The token swap not load");
        return (0, math_1.uiPrice2Tick)(price, this.tokenSwapInfo.tokenADecimals, this.tokenSwapInfo.tokenBDecimals);
    }
    uiReversePrice2Tick(price) {
        (0, tiny_invariant_1.default)(this.isLoaded, "The token swap not load");
        return (0, math_1.uiPrice2Tick)(new decimal_js_1.default(1).div(price), this.tokenSwapInfo.tokenADecimals, this.tokenSwapInfo.tokenBDecimals);
    }
    uiPrice2NearestTick(price) {
        (0, tiny_invariant_1.default)(this.isLoaded, "The token swap not load");
        const swapPrice = (0, math_1.uiPrice2LamportPrice)(price, this.tokenSwapInfo.tokenADecimals, this.tokenSwapInfo.tokenBDecimals);
        return this.getNearestTickByPrice(swapPrice);
    }
    uiReversePrice2NearestTick(price) {
        (0, tiny_invariant_1.default)(this.isLoaded, "The token swap not load");
        const swapPrice = (0, math_1.uiPrice2LamportPrice)(new decimal_js_1.default(1).div(price), this.tokenSwapInfo.tokenADecimals, this.tokenSwapInfo.tokenBDecimals);
        return this.getNearestTickByPrice(swapPrice);
    }
    tick2UiPrice(tick) {
        (0, tiny_invariant_1.default)(this.isLoaded, "The token swap not load");
        return (0, math_1.tick2UiPrice)(tick, this.tokenSwapInfo.tokenADecimals, this.tokenSwapInfo.tokenBDecimals);
    }
    tick2UiReversePrice(tick) {
        (0, tiny_invariant_1.default)(this.isLoaded, "The token swap not load");
        return new decimal_js_1.default(1).div((0, math_1.tick2UiPrice)(tick, this.tokenSwapInfo.tokenADecimals, this.tokenSwapInfo.tokenBDecimals));
    }
    tokenALamports(amount) {
        return amount
            .mul(new decimal_js_1.default(10).pow(this.tokenSwapInfo.tokenADecimals))
            .toDecimalPlaces(0);
    }
    tokenBLamports(amount) {
        return amount
            .mul(new decimal_js_1.default(10).pow(this.tokenSwapInfo.tokenBDecimals))
            .toDecimalPlaces(0);
    }
    tokenAAmount(lamport) {
        return lamport
            .toDecimalPlaces(0)
            .div(new decimal_js_1.default(10).pow(this.tokenSwapInfo.tokenADecimals));
    }
    tokenBAmount(lamport) {
        return lamport
            .toDecimalPlaces(0)
            .div(new decimal_js_1.default(10).pow(this.tokenSwapInfo.tokenBDecimals));
    }
    calculateEffectivTick(lowerPrice, upperPrice) {
        (0, tiny_invariant_1.default)(upperPrice.greaterThan(lowerPrice), "The upper price must greater than lower price");
        let lowerTick = this.uiPrice2NearestTick(lowerPrice);
        let upperTick = this.uiPrice2NearestTick(upperPrice);
        if (lowerTick === upperTick) {
            const realLowerTick = this.uiPrice2Tick(lowerPrice);
            const realUpperTick = this.uiPrice2Tick(upperPrice);
            if (Math.abs(realUpperTick - lowerTick) >
                Math.abs(realLowerTick - lowerTick)) {
                upperTick += this.tokenSwapInfo.tickSpace;
            }
            else {
                lowerTick -= this.tokenSwapInfo.tickSpace;
            }
        }
        return {
            lowerTick,
            upperTick,
        };
    }
    calculateFixSideTokenAmount(lowerTick, upperTick, amountA, amountB, balanceA, balanceB, slid = new decimal_js_1.default(0.01)) {
        let maxAmountA = new decimal_js_1.default(0);
        let maxAmountB = new decimal_js_1.default(0);
        let desiredAmountA = new decimal_js_1.default(0);
        let desiredAmountB = new decimal_js_1.default(0);
        let desiredDeltaLiquity = new decimal_js_1.default(0);
        let maxDeltaLiquity = new decimal_js_1.default(0);
        let fixTokenType = exports.FIX_TOKEN_A;
        let slidSqrtPrice = new decimal_js_1.default(0);
        // Fix token a
        if (amountA !== null) {
            (0, tiny_invariant_1.default)(amountA.lessThanOrEqualTo(balanceA));
            const lamportsA = this.tokenALamports(amountA);
            desiredAmountA = lamportsA;
            maxAmountA = lamportsA;
            const res = this.calculateLiquityByTokenA(lowerTick, upperTick, lamportsA);
            desiredAmountB = res.desiredAmountB;
            desiredDeltaLiquity = res.liquity;
            (0, tiny_invariant_1.default)(desiredAmountB.lessThanOrEqualTo(balanceB), "The fixed amount of token A is too large");
            slidSqrtPrice = this.tokenSwapInfo.currentSqrtPrice.mul(new decimal_js_1.default(1).add(slid).sqrt());
            if (slidSqrtPrice.greaterThanOrEqualTo((0, math_1.tick2SqrtPrice)(upperTick))) {
                slidSqrtPrice = (0, math_1.tick2SqrtPrice)(upperTick - 1);
            }
            const slidRes = this.calculateLiquityByTokenA(lowerTick, upperTick, lamportsA, slidSqrtPrice);
            if (slidRes.desiredAmountB.greaterThan(balanceB)) {
                maxAmountB = balanceB;
                maxDeltaLiquity = undefined;
            }
            else {
                maxAmountB = slidRes.desiredAmountB;
                maxDeltaLiquity = slidRes.liquity;
            }
        }
        else {
            (0, tiny_invariant_1.default)(amountB !== null, "You must specified the amount of token A or token B");
            (0, tiny_invariant_1.default)(amountB.lessThanOrEqualTo(balanceB));
            const lamportsB = this.tokenBLamports(amountB);
            fixTokenType = exports.FIX_TOKEN_B;
            desiredAmountB = lamportsB;
            maxAmountB = lamportsB;
            const res = this.calculateLiquityByTokenB(lowerTick, upperTick, lamportsB);
            desiredAmountA = res.desiredAmountA;
            desiredDeltaLiquity = res.liquity;
            (0, tiny_invariant_1.default)(desiredAmountA.lessThanOrEqualTo(balanceA), "The fixed amount of token B is too large");
            slidSqrtPrice = this.tokenSwapInfo.currentSqrtPrice.mul(new decimal_js_1.default(1).sub(slid).sqrt());
            if (slidSqrtPrice.lessThanOrEqualTo((0, math_1.tick2SqrtPrice)(lowerTick))) {
                slidSqrtPrice = (0, math_1.tick2SqrtPrice)(lowerTick + 1);
            }
            const slidRes = this.calculateLiquityByTokenB(lowerTick, upperTick, lamportsB, slidSqrtPrice);
            if (slidRes.desiredAmountA.greaterThan(balanceA)) {
                maxAmountA = balanceA;
                maxDeltaLiquity = undefined;
            }
            else {
                maxAmountA = slidRes.desiredAmountA;
                maxDeltaLiquity = slidRes.liquity;
            }
        }
        return {
            desiredAmountA,
            desiredAmountB,
            maxAmountA,
            maxAmountB,
            desiredDeltaLiquity,
            maxDeltaLiquity,
            fixTokenType,
            slidPrice: this.tick2UiPrice((0, math_1.sqrtPrice2Tick)(slidSqrtPrice)),
        };
    }
    async wrapSOL(amount) {
        (0, tiny_invariant_1.default)(amount.greaterThan(0));
        const tx = new solana_contrib_1.TransactionEnvelope(this.provider, []);
        const { address: ataAddress, instruction: ataInstruction } = await (0, token_utils_1.getOrCreateATA)({
            provider: this.provider,
            mint: spl_token_v2_1.NATIVE_MINT,
            owner: this.provider.wallet.publicKey,
            payer: this.provider.wallet.publicKey,
        });
        if (ataInstruction !== null) {
            tx.instructions.push(ataInstruction);
        }
        tx.instructions.push(web3_js_1.SystemProgram.transfer({
            fromPubkey: this.provider.wallet.publicKey,
            toPubkey: ataAddress,
            lamports: amount.toNumber(),
        }));
        tx.instructions.push((0, spl_token_v2_1.createSyncNativeInstruction)(ataAddress));
        return tx;
    }
    async unwrapSOL(ataAddress, dest = this.provider.wallet.publicKey) {
        const checkAta = await (0, token_utils_1.getATAAddress)({
            mint: spl_token_v2_1.NATIVE_MINT,
            owner: this.provider.wallet.publicKey,
        });
        (0, tiny_invariant_1.default)(ataAddress.equals(checkAta), "Only allow close wrap SOL ata");
        const tx = (0, spl_token_v2_1.createCloseAccountInstruction)(ataAddress, dest, this.provider.wallet.publicKey);
        return new solana_contrib_1.TransactionEnvelope(this.provider, [tx]);
    }
    async _checkUserPositionAccount(positionId, positionAccount) {
        if (!this.isLoaded) {
            await this.load();
        }
        const positionInfo = this.getPositionInfo(positionId);
        (0, tiny_invariant_1.default)(positionInfo !== undefined, `Position:${positionId.toString()} not found`);
        if (positionAccount === null) {
            positionAccount = await (0, token_utils_1.getATAAddress)({
                mint: positionId,
                owner: this.provider.wallet.publicKey,
            });
        }
        const positionAccountInfo = await (0, token_utils_1.getTokenAccount)(this.provider, positionAccount);
        (0, tiny_invariant_1.default)(positionAccountInfo.mint.toString() === positionId.toString(), `Invalid position account:${positionAccount.toBase58()}`);
        (0, tiny_invariant_1.default)(positionAccountInfo.amount.toNumber() === 1, `You not hold this position:${positionId.toBase58()}`);
        return {
            positionInfo,
            positionAccount,
        };
    }
}
exports.TokenSwap = TokenSwap;
//# sourceMappingURL=tokenSwap.js.map