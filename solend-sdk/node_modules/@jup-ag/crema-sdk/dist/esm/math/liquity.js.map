{"version":3,"file":"liquity.js","sourceRoot":"","sources":["../../../src/math/liquity.ts"],"names":[],"mappings":"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","sourcesContent":["import Decimal from \"decimal.js\";\nimport invariant from \"tiny-invariant\";\n\nimport type { Tick } from \"../state\";\nimport { tick2SqrtPrice } from \".\";\n\n/**\n * Calculate liquity and another token amount when current tick is in [tickLower, tickUpper]\n * @param tickLower The tick lower\n * @param tickUpper The tick upper\n * @param currentSqrtPrice The current sqrt price\n * @param desiredAmountSrc The src token amount\n * @param direct 0(desiredAmountSrc is TokenA), 1(desiredAmountSrc is TokenB)\n * @returns The liquity and dst token amount\n */\nexport function calculateLiquity(\n  tickLower: number,\n  tickUpper: number,\n  desiredAmountSrc: Decimal,\n  currentSqrtPrice: Decimal,\n  direct: number\n): {\n  desiredAmountDst: Decimal;\n  deltaLiquity: Decimal;\n} {\n  invariant(tickLower < tickUpper, \"The tickLower must less than tickUpper\");\n  const lowerSqrtPrice = tick2SqrtPrice(tickLower);\n  const upperSqrtPrice = tick2SqrtPrice(tickUpper);\n  invariant(\n    currentSqrtPrice.greaterThanOrEqualTo(lowerSqrtPrice) &&\n      currentSqrtPrice.lessThanOrEqualTo(upperSqrtPrice),\n    \"The current price must in [lowerPrice,upperPrice]\"\n  );\n  const one = new Decimal(1);\n  if (direct === 0) {\n    const deltaLiquity = desiredAmountSrc.div(\n      one.div(currentSqrtPrice).sub(one.div(upperSqrtPrice))\n    );\n    const desiredAmountDst = deltaLiquity.mul(\n      currentSqrtPrice.sub(lowerSqrtPrice)\n    );\n    return { desiredAmountDst, deltaLiquity };\n  } else {\n    const deltaLiquity = desiredAmountSrc.div(\n      currentSqrtPrice.sub(lowerSqrtPrice)\n    );\n    const desiredAmountDst = deltaLiquity.mul(\n      one.div(currentSqrtPrice).sub(one.div(upperSqrtPrice))\n    );\n    return { desiredAmountDst, deltaLiquity };\n  }\n}\n\n/**\n * Calculate amount out of token A and token B by liquity\n * @param tickLower The tick lower\n * @param tickUpper The tick upper\n * @param currentSqrtPrice The current sqrt price\n * @param liquity The liquity amount\n * @returns The amount of token A and token B\n */\nexport function calculateTokenAmount(\n  tickLower: number,\n  tickUpper: number,\n  liquity: Decimal,\n  currentSqrtPrice: Decimal\n): {\n  amountA: Decimal;\n  amountB: Decimal;\n} {\n  const lowerSqrtPrice = tick2SqrtPrice(tickLower);\n  const upperSqrtPrice = tick2SqrtPrice(tickUpper);\n  if (currentSqrtPrice.lessThan(lowerSqrtPrice)) {\n    return {\n      amountA: liquity\n        .div(lowerSqrtPrice)\n        .sub(liquity.div(upperSqrtPrice))\n        .toDecimalPlaces(0),\n      amountB: new Decimal(0),\n    };\n  } else if (currentSqrtPrice.greaterThan(upperSqrtPrice)) {\n    return {\n      amountA: new Decimal(0),\n      amountB: liquity\n        .mul(upperSqrtPrice)\n        .sub(liquity.mul(lowerSqrtPrice))\n        .toDecimalPlaces(0),\n    };\n  } else {\n    return {\n      amountA: liquity\n        .div(currentSqrtPrice)\n        .sub(liquity.div(upperSqrtPrice))\n        .toDecimalPlaces(0),\n      amountB: liquity\n        .mul(currentSqrtPrice)\n        .sub(liquity.mul(lowerSqrtPrice))\n        .toDecimalPlaces(0),\n    };\n  }\n}\n\n/**\n * Calculate liquity when current tick is less than tickLower\n * @param tickLower The tick lower\n * @param tickUpper The tick upper\n * @param desiredAmountA The desired amount of token A\n * @returns the liquity\n */\nexport function calculateLiquityOnlyA(\n  tickLower: number,\n  tickUpper: number,\n  desiredAmountA: Decimal\n): Decimal {\n  invariant(tickLower < tickUpper, \"The tickLower must less than tickUpper\");\n  const lowerSqrtPrice = tick2SqrtPrice(tickLower);\n  const upperSqrtPrice = tick2SqrtPrice(tickUpper);\n  const one = new Decimal(1);\n  return desiredAmountA.div(\n    one.div(lowerSqrtPrice).sub(one.div(upperSqrtPrice))\n  );\n}\n\n/**\n * Calculate liquity when current tick is less than tickLower\n * @param tickLower The tick lower\n * @param tickUpper The tick upper\n * @returns The liquity\n */\nexport function calculateLiquityOnlyB(\n  tickLower: number,\n  tickUpper: number,\n  desiredAmountB: Decimal\n): Decimal {\n  invariant(tickLower < tickUpper, \"The tickLower must less than tickUpper\");\n  const lowerSqrtPrice = tick2SqrtPrice(tickLower);\n  const upperSqrtPrice = tick2SqrtPrice(tickUpper);\n  return desiredAmountB.div(upperSqrtPrice.sub(lowerSqrtPrice));\n}\n\nexport interface Liquity {\n  lowerTick: number;\n  upperTick: number;\n  amount: Decimal;\n}\n/**\n * Calculate the liquitys table\n * @param ticks The tick array of token swap\n * @returns The min, max of liquity, and liquitys array\n */\nexport function calculateLiquityTable(ticks: Tick[]): {\n  maxLiquity: Decimal;\n  minLiquity: Decimal;\n  liquitys: Liquity[];\n} {\n  let minLiquity = new Decimal(0);\n  let maxLiquity = new Decimal(0);\n  const liquitys: Liquity[] = [];\n  const liquity: Liquity = {\n    lowerTick: 0,\n    upperTick: 0,\n    amount: new Decimal(0),\n  };\n  for (let i = 0; i < ticks.length; i++) {\n    const tick = ticks[i];\n    invariant(tick !== undefined);\n    if (liquity.amount.equals(0)) {\n      liquity.lowerTick = tick.tick;\n      liquity.amount = tick.liquityNet;\n      continue;\n    }\n    liquity.upperTick = tick.tick;\n    minLiquity =\n      liquity.amount.lessThan(minLiquity) || minLiquity.equals(0)\n        ? liquity.amount\n        : minLiquity;\n    maxLiquity = liquity.amount.greaterThan(maxLiquity)\n      ? liquity.amount\n      : maxLiquity;\n    liquitys.push({\n      lowerTick: liquity.lowerTick,\n      upperTick: liquity.upperTick,\n      amount: liquity.amount,\n    });\n    liquity.amount = liquity.amount.add(tick.liquityNet);\n    liquity.lowerTick = tick.tick;\n  }\n  return { maxLiquity, minLiquity, liquitys };\n}\n\n/**\n * Calculate max tokenAmount with sliding point.\n * @param liquity.\n */\nexport function calculateSlidTokenAmount(\n  tickLower: number,\n  tickUpper: number,\n  liquity: Decimal,\n  currentSqrtPrice: Decimal,\n  slid: Decimal\n): {\n  maxAmountA: Decimal;\n  minAmountA: Decimal;\n  maxAmountB: Decimal;\n  minAmountB: Decimal;\n  amountA: Decimal;\n  amountB: Decimal;\n} {\n  invariant(\n    slid.lessThan(1) && slid.greaterThan(0),\n    `Invalid slid:${slid.toString()}`\n  );\n  const maxSqrtPrice = currentSqrtPrice.mul(new Decimal(1).add(slid).sqrt());\n  const minSqrtPrice = currentSqrtPrice.mul(new Decimal(1).sub(slid).sqrt());\n  const constant = calculateTokenAmount(\n    tickLower,\n    tickUpper,\n    liquity,\n    currentSqrtPrice\n  );\n  const minRes = calculateTokenAmount(\n    tickLower,\n    tickUpper,\n    liquity,\n    minSqrtPrice\n  );\n  const maxRes = calculateTokenAmount(\n    tickLower,\n    tickUpper,\n    liquity,\n    maxSqrtPrice\n  );\n  return {\n    maxAmountA: minRes.amountA,\n    minAmountA: maxRes.amountA,\n    maxAmountB: maxRes.amountB,\n    minAmountB: minRes.amountB,\n    amountA: constant.amountA,\n    amountB: constant.amountB,\n  };\n}\n"]}