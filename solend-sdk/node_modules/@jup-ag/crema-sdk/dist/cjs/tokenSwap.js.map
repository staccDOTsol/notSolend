{"version":3,"file":"tokenSwap.js","sourceRoot":"","sources":["../../src/tokenSwap.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Provider } from \"@saberhq/solana-contrib\";\nimport { TransactionEnvelope } from \"@saberhq/solana-contrib\";\nimport {\n  createATAInstruction,\n  createMintInstructions,\n  getATAAddress,\n  getOrCreateATA,\n  getTokenAccount,\n} from \"@saberhq/token-utils\";\nimport {\n  createCloseAccountInstruction,\n  createSyncNativeInstruction,\n  NATIVE_MINT,\n  TOKEN_PROGRAM_ID,\n} from \"@solana/spl-token-v2\";\nimport type {\n  GetProgramAccountsConfig,\n  TransactionInstruction,\n} from \"@solana/web3.js\";\nimport { Keypair, PublicKey, SystemProgram } from \"@solana/web3.js\";\nimport BN from \"bn.js\";\nimport * as bs58 from \"bs58\";\nimport Decimal from \"decimal.js\";\nimport invariant from \"tiny-invariant\";\n\nimport {\n  addUserPositionInstruction,\n  claimInstruction,\n  depositAllTokenTypesInstruction,\n  initializeInstruction,\n  managerClaimInstruction,\n  simulateSwapInstruction,\n  swapInstruction,\n  withdrawAllTokenTypesInstruction,\n} from \"./instructions\";\nimport { depositFixTokenInstruction } from \"./instructions/depositFixToken\";\nimport {\n  calculateLiquity,\n  calculateLiquityOnlyA,\n  calculateLiquityOnlyB,\n  calculateSlidTokenAmount,\n  calculateSwapA2B,\n  calculateSwapB2A,\n  calculateTokenAmount,\n  getNearestTickByPrice,\n  lamportPrice2uiPrice,\n  sqrtPrice2Tick,\n  tick2SqrtPrice,\n  tick2UiPrice,\n  uiPrice2LamportPrice,\n  uiPrice2Tick,\n} from \"./math\";\nimport type { Tick, TokenSwapAccount } from \"./state\";\nimport {\n  isPositionsAccount,\n  isTicksAccount,\n  isTokenSwapAccount,\n  MAX_ACCOUNT_POSITION_LENGTH,\n  parsePositionsAccount,\n  parseTicksAccount,\n  parseTokenSwapAccount,\n  POSITIONS_ACCOUNT_SIZE,\n  TOKEN_SWAP_ACCOUNT_SIZE,\n} from \"./state\";\nimport { getTokenAccounts } from \"./util/token\";\n\nexport const INIT_KEY = new PublicKey(\"11111111111111111111111111111111\");\nexport const SWAP_B2A = 1;\nexport const SWAP_A2B = 0;\nexport const FIX_TOKEN_A = 0;\nexport const FIX_TOKEN_B = 1;\nexport interface PositionInfo {\n  positionsKey: PublicKey;\n  index: Decimal;\n  positionId: PublicKey;\n  lowerTick: number;\n  upperTick: number;\n  liquity: Decimal;\n  feeGrowthInsideALast: Decimal;\n  feeGrowthInsideBLast: Decimal;\n  tokenAFee: Decimal;\n  tokenBFee: Decimal;\n}\n\nexport interface SwapPairInfo extends TokenSwapAccount {\n  tokenADecimals: number;\n  tokenBDecimals: number;\n}\n\nDecimal.config({\n  precision: 64,\n  rounding: Decimal.ROUND_HALF_DOWN,\n  toExpNeg: -64,\n  toExpPos: 64,\n});\n\nexport interface PendingCreateSwapPair {\n  swapKey: PublicKey;\n  positionsKey: PublicKey;\n  ticksKey: PublicKey;\n  swapTokenA: PublicKey;\n  swapTokenB: PublicKey;\n  managerTokenA: PublicKey;\n  managerTokenB: PublicKey;\n  authority: PublicKey;\n  tx: TransactionEnvelope;\n}\n\nexport interface PendingMintPosition {\n  positionId: PublicKey;\n  positionAccount: PublicKey;\n  positionsKey: PublicKey;\n  tx: TransactionEnvelope;\n}\n\n/**\n * The token swap class\n */\nexport class TokenSwap {\n  provider: Provider;\n  programId: PublicKey = INIT_KEY;\n  tokenSwapKey: PublicKey = INIT_KEY;\n  authority: PublicKey = INIT_KEY;\n  isLoaded = false;\n  currentTick = 0;\n  tokenSwapInfo: SwapPairInfo = {\n    tokenSwapKey: INIT_KEY,\n    accountType: 0,\n    version: 0,\n    isInitialized: 0,\n    nonce: 0,\n    tokenProgramId: TOKEN_PROGRAM_ID,\n    manager: INIT_KEY,\n    managerTokenA: INIT_KEY,\n    managerTokenB: INIT_KEY,\n    swapTokenA: INIT_KEY,\n    swapTokenB: INIT_KEY,\n    tokenAMint: INIT_KEY,\n    tokenBMint: INIT_KEY,\n    ticksKey: INIT_KEY,\n    positionsKey: INIT_KEY,\n    curveType: 0,\n    fee: new Decimal(0),\n    managerFee: new Decimal(0),\n    tickSpace: 0,\n    currentSqrtPrice: new Decimal(0),\n    currentLiquity: new Decimal(0),\n    feeGrowthGlobal0: new Decimal(0),\n    feeGrowthGlobal1: new Decimal(0),\n    managerFeeA: new Decimal(0),\n    managerFeeB: new Decimal(0),\n    tokenADecimals: 0,\n    tokenBDecimals: 0,\n  };\n  ticks: Tick[] = [];\n  positions: Map<string, PositionInfo>;\n  positionsKeys: Map<PublicKey, number>;\n\n  /**\n   * The constructor of TokenSwap\n   * @param programId The token swap program id\n   * @param tokenSwapKey The token swap key\n   */\n  constructor(\n    provider: Provider,\n    programId: PublicKey,\n    tokenSwapKey: PublicKey\n  ) {\n    this.provider = provider;\n    this.tokenSwapKey = tokenSwapKey;\n    this.programId = programId;\n    this.positions = new Map();\n    this.positionsKeys = new Map();\n  }\n\n  /**\n   * Load the token swap info\n   */\n  async load(): Promise<TokenSwap> {\n    const config: GetProgramAccountsConfig = {\n      encoding: \"base64\",\n      filters: [\n        {\n          memcmp: {\n            offset: 1,\n            bytes: this.tokenSwapKey.toBase58(),\n          },\n        },\n      ],\n    };\n    const accounts = await this.provider.connection.getProgramAccounts(\n      this.programId,\n      config\n    );\n    accounts.map((item) => {\n      if (isTokenSwapAccount(item.account)) {\n        const info = parseTokenSwapAccount(item.pubkey, item.account);\n        invariant(\n          info?.data !== undefined,\n          \"The token swap account parse failed\"\n        );\n        this.tokenSwapInfo = {\n          ...info.data,\n          tokenADecimals: this.tokenSwapInfo.tokenADecimals,\n          tokenBDecimals: this.tokenSwapInfo.tokenBDecimals,\n        };\n      } else if (isTicksAccount(item.account)) {\n        const info = parseTicksAccount(item.pubkey, item.account);\n        invariant(info?.data !== undefined, \"The tick account parse failed\");\n        this.ticks = info.data.ticks;\n      } else if (isPositionsAccount(item.account)) {\n        const info = parsePositionsAccount(item.pubkey, item.account);\n        invariant(\n          info?.data !== undefined,\n          \"The position account data parse failed\"\n        );\n        this.positionsKeys.set(item.pubkey, info.data.positions.length);\n        for (let i = 0; i < info.data.positions.length; i++) {\n          const p = info.data.positions[i];\n          invariant(p !== undefined);\n          this.positions.set(p.nftTokenId.toBase58(), {\n            positionsKey: item.pubkey,\n            index: new Decimal(i),\n            positionId: p.nftTokenId,\n            lowerTick: p.lowerTick,\n            upperTick: p.upperTick,\n            liquity: p.liquity,\n            feeGrowthInsideALast: p.feeGrowthInsideALast,\n            feeGrowthInsideBLast: p.feeGrowthInsideBLast,\n            tokenAFee: p.tokenAFee,\n            tokenBFee: p.tokenBFee,\n          });\n        }\n      } else {\n        console.log(\n          \"the account:%s length:%d unkown\",\n          item.pubkey.toString(),\n          item.account.data.length\n        );\n      }\n    });\n    if (this.authority.toString() === INIT_KEY.toString()) {\n      const [authority] = await PublicKey.findProgramAddress(\n        [this.tokenSwapKey.toBuffer()],\n        this.programId\n      );\n      this.authority = authority;\n    }\n    if (!this.isLoaded) {\n      const tokenASupply = await this.provider.connection.getTokenSupply(\n        this.tokenSwapInfo.tokenAMint\n      );\n      const tokenBSupply = await this.provider.connection.getTokenSupply(\n        this.tokenSwapInfo.tokenBMint\n      );\n      this.tokenSwapInfo.tokenADecimals = tokenASupply.value.decimals;\n      this.tokenSwapInfo.tokenBDecimals = tokenBSupply.value.decimals;\n    }\n    this.isLoaded = true;\n    this.currentTick = sqrtPrice2Tick(this.tokenSwapInfo.currentSqrtPrice);\n    return this;\n  }\n\n  /**\n   * Fetch the swap list\n   */\n  static async fetchSwapPairs(\n    provider: Provider,\n    programId: PublicKey\n  ): Promise<Array<TokenSwapAccount>> {\n    const config: GetProgramAccountsConfig = {\n      filters: [\n        {\n          memcmp: {\n            offset: 33,\n            bytes: bs58.encode(new BN(0).toArrayLike(Buffer, \"le\", 1)),\n          },\n        },\n        {\n          dataSize: TOKEN_SWAP_ACCOUNT_SIZE,\n        },\n      ],\n    };\n    const accounts = await provider.connection.getProgramAccounts(\n      programId,\n      config\n    );\n    const list: TokenSwapAccount[] = [];\n    accounts.forEach((v) => {\n      if (isTokenSwapAccount(v.account)) {\n        const info = parseTokenSwapAccount(v.pubkey, v.account);\n        invariant(\n          info?.data !== undefined,\n          \"The token swap account parse failed\"\n        );\n        list.push(info.data);\n      }\n    });\n    return list;\n  }\n\n  static async createTokenSwap({\n    provider,\n    programId,\n    tokenAMint,\n    tokenBMint,\n    manager,\n    fee,\n    managerFee,\n    tickSpace,\n    tickAccountSize,\n    initializePrice,\n  }: {\n    provider: Provider;\n    programId: PublicKey;\n    tokenAMint: PublicKey;\n    tokenBMint: PublicKey;\n    manager: PublicKey;\n    fee: Decimal;\n    managerFee: Decimal;\n    tickSpace: number;\n    tickAccountSize: number;\n    initializePrice: Decimal;\n  }): Promise<PendingCreateSwapPair> {\n    // generate account create instruction that token swap need\n    const instructions: TransactionInstruction[] = [];\n    const swapAccount = Keypair.generate();\n    const ticksAccount = Keypair.generate();\n    const positionsAccount = Keypair.generate();\n    const [authority, nonce] = await PublicKey.findProgramAddress(\n      [swapAccount.publicKey.toBuffer()],\n      programId\n    );\n    const ticksAccountLamports =\n      await provider.connection.getMinimumBalanceForRentExemption(\n        tickAccountSize\n      );\n    const positionsAccountLarports =\n      await provider.connection.getMinimumBalanceForRentExemption(\n        POSITIONS_ACCOUNT_SIZE\n      );\n    const swapAccountLamports =\n      await provider.connection.getMinimumBalanceForRentExemption(\n        TOKEN_SWAP_ACCOUNT_SIZE\n      );\n    // generate create token swap authority token account instruction\n    const swapTokenA = await getATAAddress({\n      mint: tokenAMint,\n      owner: authority,\n    });\n    const swapTokenB = await getATAAddress({\n      mint: tokenBMint,\n      owner: authority,\n    });\n    instructions.push(\n      SystemProgram.createAccount({\n        fromPubkey: provider.wallet.publicKey,\n        newAccountPubkey: swapAccount.publicKey,\n        lamports: swapAccountLamports,\n        space: TOKEN_SWAP_ACCOUNT_SIZE,\n        programId: programId,\n      }),\n      SystemProgram.createAccount({\n        fromPubkey: provider.wallet.publicKey,\n        newAccountPubkey: ticksAccount.publicKey,\n        lamports: ticksAccountLamports,\n        space: tickAccountSize,\n        programId: programId,\n      }),\n      SystemProgram.createAccount({\n        fromPubkey: provider.wallet.publicKey,\n        newAccountPubkey: positionsAccount.publicKey,\n        lamports: positionsAccountLarports,\n        space: POSITIONS_ACCOUNT_SIZE,\n        programId: programId,\n      })\n    );\n\n    // generate create token swap authority token account instruction\n    instructions.push(\n      createATAInstruction({\n        address: swapTokenA,\n        mint: tokenAMint,\n        owner: authority,\n        payer: provider.wallet.publicKey,\n      }),\n      createATAInstruction({\n        address: swapTokenB,\n        mint: tokenBMint,\n        owner: authority,\n        payer: provider.wallet.publicKey,\n      })\n    );\n\n    // generate token swap initialize instruction\n    const currentSqrtPrice = initializePrice.sqrt();\n    const managerTokenA = await getATAAddress({\n      mint: tokenAMint,\n      owner: manager,\n    });\n    const managerTokenB = await getATAAddress({\n      mint: tokenBMint,\n      owner: manager,\n    });\n    const curveType = 0;\n    instructions.push(\n      initializeInstruction(\n        programId,\n        swapAccount.publicKey,\n        authority,\n        manager,\n        managerTokenA,\n        managerTokenB,\n        swapTokenA,\n        swapTokenB,\n        ticksAccount.publicKey,\n        positionsAccount.publicKey,\n        nonce,\n        curveType,\n        fee,\n        managerFee,\n        tickSpace,\n        currentSqrtPrice\n      )\n    );\n    return {\n      swapKey: swapAccount.publicKey,\n      positionsKey: positionsAccount.publicKey,\n      ticksKey: ticksAccount.publicKey,\n      swapTokenA,\n      swapTokenB,\n      managerTokenA,\n      managerTokenB,\n      authority,\n      tx: new TransactionEnvelope(provider, instructions, [\n        swapAccount,\n        ticksAccount,\n        positionsAccount,\n      ]),\n    };\n  }\n\n  /**\n   *\n   * @param userTokenA The user address of token A\n   * @param userTokenB The user address of token B\n   * @param lowerTick The lower tick\n   * @param upperTick The upper tick\n   * @param liquity The liquity amount\n   * @param maximumAmountA The maximum amount of Token A\n   * @param maximumAmountB The maximum amount of Token B\n   * @returns\n   */\n  async mintPosition(\n    userTokenA: PublicKey,\n    userTokenB: PublicKey,\n    lowerTick: number,\n    upperTick: number,\n    liquity: Decimal,\n    maximumAmountA: Decimal,\n    maximumAmountB: Decimal\n  ): Promise<PendingMintPosition> {\n    if (this.isLoaded) {\n      await this.load();\n    }\n    invariant(\n      lowerTick < upperTick,\n      \"The lowerTick must be less than upperTick\"\n    );\n\n    const instructions: TransactionInstruction[] = [];\n\n    // Generate create position nft token instructions\n    const positionNftMint = Keypair.generate();\n    const positionAccount = await getATAAddress({\n      mint: positionNftMint.publicKey,\n      owner: this.provider.wallet.publicKey,\n    });\n\n    const nftMintInstructions = await createMintInstructions(\n      this.provider,\n      this.authority,\n      positionNftMint.publicKey,\n      0\n    );\n    instructions.push(...nftMintInstructions);\n    instructions.push(\n      createATAInstruction({\n        address: positionAccount,\n        mint: positionNftMint.publicKey,\n        owner: this.provider.wallet.publicKey,\n        payer: this.provider.wallet.publicKey,\n      })\n    );\n\n    const positionsKey = this.choosePosition();\n    invariant(positionsKey !== null, \"The position account space if full\");\n    // Generate mint positon instruction\n    instructions.push(\n      depositAllTokenTypesInstruction(\n        this.programId,\n        this.tokenSwapKey,\n        this.authority,\n        this.provider.wallet.publicKey,\n        userTokenA,\n        userTokenB,\n        this.tokenSwapInfo.swapTokenA,\n        this.tokenSwapInfo.swapTokenB,\n        positionNftMint.publicKey,\n        positionAccount,\n        this.tokenSwapInfo.ticksKey,\n        positionsKey,\n        0,\n        lowerTick,\n        upperTick,\n        liquity,\n        maximumAmountA,\n        maximumAmountB,\n        new Decimal(0)\n      )\n    );\n\n    if (\n      this.tokenSwapInfo.tokenAMint.equals(NATIVE_MINT) &&\n      maximumAmountA.greaterThan(0)\n    ) {\n      const wrapSOLInstructions = await this.wrapSOL(maximumAmountA);\n      instructions.unshift(...wrapSOLInstructions.instructions);\n      const unwrapSOLInstructions = await this.unwrapSOL(userTokenA);\n      instructions.push(...unwrapSOLInstructions.instructions);\n    }\n    if (\n      this.tokenSwapInfo.tokenBMint.equals(NATIVE_MINT) &&\n      maximumAmountB.greaterThan(0)\n    ) {\n      const wrapSOLInstructions = await this.wrapSOL(maximumAmountB);\n      instructions.unshift(...wrapSOLInstructions.instructions);\n      const unwrapSOLInstructions = await this.unwrapSOL(userTokenB);\n      instructions.push(...unwrapSOLInstructions.instructions);\n    }\n\n    return {\n      positionId: positionNftMint.publicKey,\n      positionAccount,\n      positionsKey,\n      tx: new TransactionEnvelope(this.provider, instructions, [\n        positionNftMint,\n      ]),\n    };\n  }\n\n  /**\n   * Mint a position and you can specified a fix token amount.\n   * @param userTokenA The user address of token A\n   * @param userTokenB The user address of token B\n   * @param fixTokenType 0-FixTokenA 1-FixTokenB\n   * @param lowerTick The lower tick\n   * @param upperTick The upper tick\n   * @param maximumAmountA The maximum amount of Token A\n   * @param maximumAmountB The maximum amount of Token B\n   * @returns\n   */\n  async mintPositionFixToken(\n    userTokenA: PublicKey,\n    userTokenB: PublicKey,\n    fixTokenType: number,\n    lowerTick: number,\n    upperTick: number,\n    maximumAmountA: Decimal,\n    maximumAmountB: Decimal\n  ): Promise<PendingMintPosition> {\n    if (this.isLoaded) {\n      await this.load();\n    }\n    invariant(\n      lowerTick < upperTick,\n      \"The lowerTick must be less than upperTick\"\n    );\n\n    const instructions: TransactionInstruction[] = [];\n\n    // Generate create position nft token instructions\n    const positionNftMint = Keypair.generate();\n    const positionAccount = await getATAAddress({\n      mint: positionNftMint.publicKey,\n      owner: this.provider.wallet.publicKey,\n    });\n\n    const nftMintInstructions = await createMintInstructions(\n      this.provider,\n      this.authority,\n      positionNftMint.publicKey,\n      0\n    );\n    instructions.push(...nftMintInstructions);\n    instructions.push(\n      createATAInstruction({\n        address: positionAccount,\n        mint: positionNftMint.publicKey,\n        owner: this.provider.wallet.publicKey,\n        payer: this.provider.wallet.publicKey,\n      })\n    );\n\n    const positionsKey = this.choosePosition();\n    invariant(positionsKey !== null, \"The position account space if full\");\n    // Generate mint positon instruction\n    instructions.push(\n      depositFixTokenInstruction(\n        this.programId,\n        this.tokenSwapKey,\n        this.authority,\n        this.provider.wallet.publicKey,\n        userTokenA,\n        userTokenB,\n        this.tokenSwapInfo.swapTokenA,\n        this.tokenSwapInfo.swapTokenB,\n        positionNftMint.publicKey,\n        positionAccount,\n        this.tokenSwapInfo.ticksKey,\n        positionsKey,\n        0,\n        fixTokenType,\n        lowerTick,\n        upperTick,\n        maximumAmountA,\n        maximumAmountB,\n        new Decimal(0)\n      )\n    );\n\n    if (\n      this.tokenSwapInfo.tokenAMint.equals(NATIVE_MINT) &&\n      maximumAmountA.greaterThan(0)\n    ) {\n      const wrapSOLInstructions = await this.wrapSOL(maximumAmountA);\n      instructions.unshift(...wrapSOLInstructions.instructions);\n      const unwrapSOLInstructions = await this.unwrapSOL(userTokenA);\n      instructions.push(...unwrapSOLInstructions.instructions);\n    }\n    if (\n      this.tokenSwapInfo.tokenBMint.equals(NATIVE_MINT) &&\n      maximumAmountB.greaterThan(0)\n    ) {\n      const wrapSOLInstructions = await this.wrapSOL(maximumAmountB);\n      instructions.unshift(...wrapSOLInstructions.instructions);\n      const unwrapSOLInstructions = await this.unwrapSOL(userTokenB);\n      instructions.push(...unwrapSOLInstructions.instructions);\n    }\n\n    return {\n      positionId: positionNftMint.publicKey,\n      positionAccount,\n      positionsKey,\n      tx: new TransactionEnvelope(this.provider, instructions, [\n        positionNftMint,\n      ]),\n    };\n  }\n\n  /**\n   * Increase liquity on a exist position\n   * @param positionId The position id (nft mint address)\n   * @param userTokenA The user address of token A\n   * @param userTokenB The user address of token B\n   * @param liquity The liquity amount\n   * @param maximumAmountA The maximum of token A\n   * @param maximumAmountB The maximum of token B\n   * @returns\n   */\n  async increaseLiquity(\n    positionId: PublicKey,\n    userTokenA: PublicKey,\n    userTokenB: PublicKey,\n    liquity: Decimal,\n    maximumAmountA: Decimal,\n    maximumAmountB: Decimal,\n    positionAccount: PublicKey | null = null\n  ): Promise<TransactionEnvelope> {\n    if (!this.isLoaded) {\n      await this.load();\n    }\n    const position = await this._checkUserPositionAccount(\n      positionId,\n      positionAccount\n    );\n\n    const tx = new TransactionEnvelope(this.provider, [\n      depositAllTokenTypesInstruction(\n        this.programId,\n        this.tokenSwapKey,\n        this.authority,\n        this.provider.wallet.publicKey,\n        userTokenA,\n        userTokenB,\n        this.tokenSwapInfo.swapTokenA,\n        this.tokenSwapInfo.swapTokenB,\n        positionId,\n        position.positionAccount,\n        this.tokenSwapInfo.ticksKey,\n        position.positionInfo.positionsKey,\n        1,\n        position.positionInfo.lowerTick,\n        position.positionInfo.upperTick,\n        liquity,\n        maximumAmountA,\n        maximumAmountB,\n        position.positionInfo.index\n      ),\n    ]);\n\n    if (\n      this.tokenSwapInfo.tokenAMint.equals(NATIVE_MINT) &&\n      maximumAmountA.greaterThan(0)\n    ) {\n      const wrapSOLInstructions = await this.wrapSOL(maximumAmountA);\n      tx.instructions.unshift(...wrapSOLInstructions.instructions);\n      const unwrapSOLInstructions = await this.unwrapSOL(userTokenA);\n      tx.instructions.push(...unwrapSOLInstructions.instructions);\n    }\n    if (\n      this.tokenSwapInfo.tokenBMint.equals(NATIVE_MINT) &&\n      maximumAmountB.greaterThan(0)\n    ) {\n      const wrapSOLInstructions = await this.wrapSOL(maximumAmountB);\n      tx.instructions.unshift(...wrapSOLInstructions.instructions);\n      const unwrapSOLInstructions = await this.unwrapSOL(userTokenB);\n      tx.instructions.push(...unwrapSOLInstructions.instructions);\n    }\n    return tx;\n  }\n\n  /**\n   * Increase liquity on a exist position and you can specified a fix token amount.\n   * @param positionId The position id (nft mint address)\n   * @param userTokenA The user address of token A\n   * @param userTokenB The user address of token B\n   * @param fixTokenType The liquity amount\n   * @param maximumAmountA The maximum of token A\n   * @param maximumAmountB The maximum of token B\n   * @returns\n   */\n  async increaseLiquityFixToken(\n    positionId: PublicKey,\n    userTokenA: PublicKey,\n    userTokenB: PublicKey,\n    fixTokenType: number,\n    maximumAmountA: Decimal,\n    maximumAmountB: Decimal,\n    positionAccount: PublicKey | null = null\n  ): Promise<TransactionEnvelope> {\n    if (!this.isLoaded) {\n      await this.load();\n    }\n    const position = await this._checkUserPositionAccount(\n      positionId,\n      positionAccount\n    );\n\n    const tx = new TransactionEnvelope(this.provider, [\n      depositFixTokenInstruction(\n        this.programId,\n        this.tokenSwapKey,\n        this.authority,\n        this.provider.wallet.publicKey,\n        userTokenA,\n        userTokenB,\n        this.tokenSwapInfo.swapTokenA,\n        this.tokenSwapInfo.swapTokenB,\n        positionId,\n        position.positionAccount,\n        this.tokenSwapInfo.ticksKey,\n        position.positionInfo.positionsKey,\n        1,\n        fixTokenType,\n        position.positionInfo.lowerTick,\n        position.positionInfo.upperTick,\n        maximumAmountA,\n        maximumAmountB,\n        position.positionInfo.index\n      ),\n    ]);\n\n    if (\n      this.tokenSwapInfo.tokenAMint.equals(NATIVE_MINT) &&\n      maximumAmountA.greaterThan(0)\n    ) {\n      const wrapSOLInstructions = await this.wrapSOL(maximumAmountA);\n      tx.instructions.unshift(...wrapSOLInstructions.instructions);\n      const unwrapSOLInstructions = await this.unwrapSOL(userTokenA);\n      tx.instructions.push(...unwrapSOLInstructions.instructions);\n    }\n    if (\n      this.tokenSwapInfo.tokenBMint.equals(NATIVE_MINT) &&\n      maximumAmountB.greaterThan(0)\n    ) {\n      const wrapSOLInstructions = await this.wrapSOL(maximumAmountB);\n      tx.instructions.unshift(...wrapSOLInstructions.instructions);\n      const unwrapSOLInstructions = await this.unwrapSOL(userTokenB);\n      tx.instructions.push(...unwrapSOLInstructions.instructions);\n    }\n\n    return tx;\n  }\n\n  /**\n   * Decrease liquity, after decrease if liquity amount is zero the position will be remove\n   * @param positionId The position id (nft mint address)\n   * @param userTokenA The user address of token A\n   * @param userTokenB The user address of token B\n   * @param liquity The liquity amount\n   * @param minimumAmountA The minimum amount of token A want recv\n   * @param minimumAmountB The minimum amount of token b want recv\n   * @returns\n   */\n  async decreaseLiquity(\n    positionId: PublicKey,\n    userTokenA: PublicKey,\n    userTokenB: PublicKey,\n    liquity: Decimal,\n    minimumAmountA: Decimal,\n    minimumAmountB: Decimal,\n    positionAccount: PublicKey | null = null\n  ): Promise<TransactionEnvelope> {\n    if (!this.isLoaded) {\n      await this.load();\n    }\n\n    const position = await this._checkUserPositionAccount(\n      positionId,\n      positionAccount\n    );\n\n    // Create withdrawAllTokenTypes instruction\n    const tx = new TransactionEnvelope(this.provider, [\n      withdrawAllTokenTypesInstruction(\n        this.programId,\n        this.tokenSwapKey,\n        this.authority,\n        this.provider.wallet.publicKey,\n        this.tokenSwapInfo.swapTokenA,\n        this.tokenSwapInfo.swapTokenB,\n        userTokenA,\n        userTokenB,\n        positionId,\n        position.positionAccount,\n        this.tokenSwapInfo.ticksKey,\n        position.positionInfo.positionsKey,\n        liquity,\n        minimumAmountA,\n        minimumAmountB,\n        position.positionInfo.index\n      ),\n    ]);\n\n    if (this.tokenSwapInfo.tokenAMint.equals(NATIVE_MINT)) {\n      const unwrapSOLTx = await this.unwrapSOL(userTokenA);\n      tx.instructions.push(...unwrapSOLTx.instructions);\n    }\n\n    if (this.tokenSwapInfo.tokenBMint.equals(NATIVE_MINT)) {\n      const unwrapSOLTx = await this.unwrapSOL(userTokenB);\n      tx.instructions.push(...unwrapSOLTx.instructions);\n    }\n    return tx;\n  }\n\n  /**\n   * Decrease liquity, after decrease if liquity amount is zero the position will be remove,\n   * if user ATA not exist, it will be create.\n   * @param positionId The position id (nft mint address)\n   * @param liquity The liquity amount\n   * @param minimumAmountA The minimum amount of token A want recv\n   * @param minimumAmountB The minimum amount of token b want recv\n   * @returns\n   */\n  async decreaseLiquityAtomic(\n    positionId: PublicKey,\n    liquity: Decimal,\n    minimumAmountA: Decimal,\n    minimumAmountB: Decimal,\n    positionAccount: PublicKey | null = null\n  ): Promise<TransactionEnvelope> {\n    const { address: tokenAATA, instruction: tokenAATAInstruction } =\n      await getOrCreateATA({\n        provider: this.provider,\n        mint: this.tokenSwapInfo.tokenAMint,\n        owner: this.provider.wallet.publicKey,\n        payer: this.provider.wallet.publicKey,\n      });\n    const { address: tokenBATA, instruction: tokenBATAInstruction } =\n      await getOrCreateATA({\n        provider: this.provider,\n        mint: this.tokenSwapInfo.tokenBMint,\n        owner: this.provider.wallet.publicKey,\n        payer: this.provider.wallet.publicKey,\n      });\n    const instructions: TransactionInstruction[] = [];\n    if (tokenAATAInstruction !== null) {\n      instructions.push(tokenAATAInstruction);\n    }\n    if (tokenBATAInstruction !== null) {\n      instructions.push(tokenBATAInstruction);\n    }\n\n    const tx = await this.decreaseLiquity(\n      positionId,\n      tokenAATA,\n      tokenBATA,\n      liquity,\n      minimumAmountA,\n      minimumAmountB,\n      positionAccount\n    );\n\n    tx.instructions.unshift(...instructions);\n\n    return tx;\n  }\n\n  /**\n   *\n   * @param userSource The token that user want swap out\n   * @param userDestination The token that user want swap in\n   * @param direct 0-A swap B, 1-B swap A\n   * @param amountIn The amount in\n   * @param minimumAmountOut The minimum amount out\n   * @returns\n   */\n  async swap(\n    userSource: PublicKey,\n    userDestination: PublicKey,\n    direct: number,\n    amountIn: Decimal,\n    minimumAmountOut: Decimal\n  ): Promise<TransactionEnvelope> {\n    if (!this.isLoaded) {\n      await this.load();\n    }\n    const { swapSrc, swapDst } =\n      direct === SWAP_A2B\n        ? {\n            swapSrc: this.tokenSwapInfo.swapTokenA,\n            swapDst: this.tokenSwapInfo.swapTokenB,\n          }\n        : {\n            swapSrc: this.tokenSwapInfo.swapTokenB,\n            swapDst: this.tokenSwapInfo.swapTokenA,\n          };\n\n    const tx = new TransactionEnvelope(this.provider, [\n      swapInstruction(\n        this.programId,\n        this.tokenSwapKey,\n        this.authority,\n        this.provider.wallet.publicKey,\n        userSource,\n        userDestination,\n        swapSrc,\n        swapDst,\n        this.tokenSwapInfo.ticksKey,\n        amountIn,\n        minimumAmountOut\n      ),\n    ]);\n\n    if (this.tokenSwapInfo.tokenAMint.equals(NATIVE_MINT)) {\n      if (direct === SWAP_A2B) {\n        const wrapSOLTx = await this.wrapSOL(amountIn);\n        tx.instructions.unshift(...wrapSOLTx.instructions);\n        const unwrapSOLTx = await this.unwrapSOL(userSource);\n        tx.instructions.push(...unwrapSOLTx.instructions);\n      } else {\n        const unwrapSOLTx = await this.unwrapSOL(userDestination);\n        tx.instructions.push(...unwrapSOLTx.instructions);\n      }\n    }\n\n    if (this.tokenSwapInfo.tokenBMint.equals(NATIVE_MINT)) {\n      if (direct === SWAP_A2B) {\n        const unwrapSOLTx = await this.unwrapSOL(userDestination);\n        tx.instructions.push(...unwrapSOLTx.instructions);\n      } else {\n        const wrapSOLTx = await this.wrapSOL(amountIn);\n        tx.instructions.unshift(...wrapSOLTx.instructions);\n        const unwrapSOLTx = await this.unwrapSOL(userSource);\n        tx.instructions.push(...unwrapSOLTx.instructions);\n      }\n    }\n\n    return tx;\n  }\n\n  /**\n   * Token swap, if the dst ATA not exist it will create it.\n   * @param direct 0-A swap B, 1-B swap A\n   * @param amountIn The amount in\n   * @param minimumAmountOut The minimum amount out\n   * @returns\n   */\n  async swapAtomic(\n    direct: number,\n    amountIn: Decimal,\n    minimumAmountOut: Decimal\n  ): Promise<TransactionEnvelope> {\n    const { srcMint, dstMint } =\n      direct === SWAP_A2B\n        ? {\n            srcMint: this.tokenSwapInfo.tokenAMint,\n            dstMint: this.tokenSwapInfo.tokenBMint,\n          }\n        : {\n            srcMint: this.tokenSwapInfo.tokenBMint,\n            dstMint: this.tokenSwapInfo.tokenAMint,\n          };\n    const { address: dstATA, instruction: dstATAInstruction } =\n      await getOrCreateATA({\n        provider: this.provider,\n        mint: dstMint,\n        owner: this.provider.wallet.publicKey,\n        payer: this.provider.wallet.publicKey,\n      });\n    const instructions: TransactionInstruction[] = [];\n    if (dstATAInstruction !== null) {\n      instructions.push(dstATAInstruction);\n    }\n    const srcATA = await getATAAddress({\n      mint: srcMint,\n      owner: this.provider.wallet.publicKey,\n    });\n\n    const swapTx = await this.swap(\n      srcATA,\n      dstATA,\n      direct,\n      amountIn,\n      minimumAmountOut\n    );\n\n    swapTx.instructions.unshift(...instructions);\n\n    return swapTx;\n  }\n\n  async simulateSwap(amountIn: Decimal, direction: number) {\n    if (!this.isLoaded) {\n      await this.load();\n    }\n    const tx = new TransactionEnvelope(this.provider, [\n      simulateSwapInstruction(\n        this.programId,\n        this.tokenSwapKey,\n        this.tokenSwapInfo.ticksKey,\n        amountIn,\n        direction\n      ),\n    ]);\n\n    const res = await tx.simulate();\n\n    console.log(res);\n  }\n\n  /**\n   *\n   * Claim fee from specified position\n   * @param positionId The NFT token public key of position\n   * @param userTokenA The user address of token A\n   * @param userTokenB The user address of token B\n   * @param positionAccount The token account of position NFT.\n   * @returns\n   */\n  async claim(\n    positionId: PublicKey,\n    userTokenA: PublicKey,\n    userTokenB: PublicKey,\n    positionAccount: PublicKey | null = null\n  ): Promise<TransactionEnvelope> {\n    if (!this.isLoaded) {\n      await this.load();\n    }\n    const position = await this._checkUserPositionAccount(\n      positionId,\n      positionAccount\n    );\n\n    const tx = new TransactionEnvelope(this.provider, [\n      claimInstruction(\n        this.programId,\n        this.tokenSwapKey,\n        this.authority,\n        this.provider.wallet.publicKey,\n        this.tokenSwapInfo.swapTokenA,\n        this.tokenSwapInfo.swapTokenB,\n        userTokenA,\n        userTokenB,\n        positionId,\n        position.positionAccount,\n        this.tokenSwapInfo.ticksKey,\n        position.positionInfo.positionsKey,\n        position.positionInfo.index\n      ),\n    ]);\n\n    if (this.tokenSwapInfo.tokenAMint.equals(NATIVE_MINT)) {\n      const unwrapSOLTx = await this.unwrapSOL(userTokenA);\n      tx.instructions.push(...unwrapSOLTx.instructions);\n    }\n\n    if (this.tokenSwapInfo.tokenBMint.equals(NATIVE_MINT)) {\n      const unwrapSOLTx = await this.unwrapSOL(userTokenB);\n      tx.instructions.push(...unwrapSOLTx.instructions);\n    }\n    return tx;\n  }\n\n  /**\n   *\n   * Claim fee from specified position, if user ATA not exist it will create.\n   * @param positionId The NFT token public key of position\n   * @param positionAccount The token account of position NFT.\n   * @returns\n   */\n  async claimAtomic(\n    positionId: PublicKey,\n    positionAccount: PublicKey | null = null\n  ): Promise<TransactionEnvelope> {\n    const { address: tokenAATA, instruction: tokenAATAInstruction } =\n      await getOrCreateATA({\n        provider: this.provider,\n        mint: this.tokenSwapInfo.tokenAMint,\n        owner: this.provider.wallet.publicKey,\n        payer: this.provider.wallet.publicKey,\n      });\n    const { address: tokenBATA, instruction: tokenBATAInstruction } =\n      await getOrCreateATA({\n        provider: this.provider,\n        mint: this.tokenSwapInfo.tokenBMint,\n        owner: this.provider.wallet.publicKey,\n        payer: this.provider.wallet.publicKey,\n      });\n    const instructions: TransactionInstruction[] = [];\n    if (tokenAATAInstruction !== null) {\n      instructions.push(tokenAATAInstruction);\n    }\n    if (tokenBATAInstruction !== null) {\n      instructions.push(tokenBATAInstruction);\n    }\n\n    const tx = await this.claim(\n      positionId,\n      tokenAATA,\n      tokenBATA,\n      positionAccount\n    );\n\n    tx.instructions.unshift(...instructions);\n\n    return tx;\n  }\n\n  /**\n   * Claim the manager fee\n   * @returns\n   */\n  async managerClaim(): Promise<TransactionEnvelope> {\n    if (!this.isLoaded) {\n      await this.load();\n    }\n    const tx = new TransactionEnvelope(this.provider, [\n      managerClaimInstruction(\n        this.programId,\n        this.tokenSwapKey,\n        this.authority,\n        this.provider.wallet.publicKey,\n        this.tokenSwapInfo.swapTokenA,\n        this.tokenSwapInfo.swapTokenB,\n        this.tokenSwapInfo.managerTokenA,\n        this.tokenSwapInfo.managerTokenB\n      ),\n    ]);\n\n    if (this.tokenSwapInfo.tokenAMint.equals(NATIVE_MINT)) {\n      const unwrapSOLTx = await this.unwrapSOL(\n        this.tokenSwapInfo.managerTokenA,\n        this.tokenSwapInfo.manager\n      );\n      tx.instructions.push(...unwrapSOLTx.instructions);\n    }\n\n    if (this.tokenSwapInfo.tokenBMint.equals(NATIVE_MINT)) {\n      const unwrapSOLTx = await this.unwrapSOL(\n        this.tokenSwapInfo.managerTokenB,\n        this.tokenSwapInfo.manager\n      );\n      tx.instructions.push(...unwrapSOLTx.instructions);\n    }\n    return tx;\n  }\n\n  /**\n   * Add a positions account for token swap\n   * @returns\n   */\n  async addPositionsAccount(): Promise<TransactionEnvelope> {\n    if (!this.isLoaded) {\n      await this.load();\n    }\n    const positionsAccount = Keypair.generate();\n    const lamports =\n      await this.provider.connection.getMinimumBalanceForRentExemption(\n        POSITIONS_ACCOUNT_SIZE\n      );\n    return new TransactionEnvelope(this.provider, [\n      SystemProgram.createAccount({\n        fromPubkey: this.provider.wallet.publicKey,\n        newAccountPubkey: positionsAccount.publicKey,\n        lamports,\n        space: POSITIONS_ACCOUNT_SIZE,\n        programId: this.programId,\n      }),\n      addUserPositionInstruction(\n        this.programId,\n        this.authority,\n        positionsAccount.publicKey\n      ),\n    ]);\n  }\n\n  /**\n   * Get user's positions\n   * @param owner The owner of position\n   * @returns The positions list\n   */\n  async getUserPositions(\n    owner = this.provider.wallet.publicKey\n  ): Promise<PositionInfo[]> {\n    invariant(this.isLoaded, \"The token swap not load\");\n    const tokenAccounts = await getTokenAccounts(\n      this.provider.connection,\n      owner\n    );\n    const positions: PositionInfo[] = [];\n    tokenAccounts.forEach((v) => {\n      const position = this.positions.get(v.mint.toBase58());\n      if (position !== undefined) {\n        positions.push(position);\n      }\n    });\n    return positions;\n  }\n\n  /**\n   * Calculate the liquity and token A amount, when the token swap currentTick < upperTick\n   * @param tickLower The lower tick\n   * @param tickUpper the upper tick\n   * @param desiredAmountA The desired token A amount\n   * @returns\n   */\n  calculateLiquityByTokenA(\n    tickLower: number,\n    tickUpper: number,\n    desiredAmountA: Decimal,\n    currentSqrtPrice = this.tokenSwapInfo.currentSqrtPrice\n  ): { desiredAmountB: Decimal; liquity: Decimal } {\n    const currentTick = sqrtPrice2Tick(currentSqrtPrice);\n    invariant(this.isLoaded, \"The token swap not load\");\n    invariant(\n      currentTick <= tickUpper,\n      \"when current price greater than upper price, can only add token b\"\n    );\n    if (currentTick < tickLower) {\n      return {\n        desiredAmountB: new Decimal(0),\n        liquity: calculateLiquityOnlyA(tickLower, tickUpper, desiredAmountA),\n      };\n    } else {\n      const res = calculateLiquity(\n        tickLower,\n        tickUpper,\n        desiredAmountA,\n        currentSqrtPrice,\n        0\n      );\n      return {\n        desiredAmountB: res.desiredAmountDst,\n        liquity: res.deltaLiquity,\n      };\n    }\n  }\n\n  /**\n   * Calculate the liquity and token B amount, when the token swap currentTick < upperTick\n   * @param tickLower The lower tick\n   * @param tickUpper the upper tick\n   * @returns\n   */\n  calculateLiquityByTokenB(\n    tickLower: number,\n    tickUpper: number,\n    desiredAmountB: Decimal,\n    currentSqrtPrice = this.tokenSwapInfo.currentSqrtPrice\n  ): { desiredAmountA: Decimal; liquity: Decimal } {\n    const currentTick = sqrtPrice2Tick(currentSqrtPrice);\n    invariant(this.isLoaded, \"The token swap not load\");\n    invariant(\n      currentTick >= tickLower,\n      \"when current price less than lower price, can only add token a\"\n    );\n    if (currentTick > tickUpper) {\n      return {\n        desiredAmountA: new Decimal(0),\n        liquity: calculateLiquityOnlyB(tickLower, tickUpper, desiredAmountB),\n      };\n    } else {\n      const res = calculateLiquity(\n        tickLower,\n        tickUpper,\n        desiredAmountB,\n        currentSqrtPrice,\n        1\n      );\n      return {\n        desiredAmountA: res.desiredAmountDst,\n        liquity: res.deltaLiquity,\n      };\n    }\n  }\n\n  // Calculate the liquity with price slid\n  calculateLiquityWithSlid({\n    lowerTick,\n    upperTick,\n    amountA = null,\n    amountB = null,\n    slid = new Decimal(0.01),\n  }: {\n    lowerTick: number;\n    upperTick: number;\n    amountA: Decimal | null;\n    amountB: Decimal | null;\n    slid: Decimal;\n  }): {\n    liquity: Decimal;\n    amountA: Decimal;\n    amountB: Decimal;\n    maximumAmountA: Decimal;\n    maximumAmountB: Decimal;\n    minimumAmountA: Decimal;\n    minimumAmountB: Decimal;\n  } {\n    invariant(amountA !== null || amountB !== null, \"the amout is null\");\n    let liquity = new Decimal(0);\n\n    const lamportA =\n      amountA !== null ? this.tokenALamports(amountA).toDecimalPlaces(0) : null;\n    const lamportB =\n      amountB !== null ? this.tokenBLamports(amountB).toDecimalPlaces(0) : null;\n\n    if (lamportA !== null) {\n      liquity = this.calculateLiquityByTokenA(\n        lowerTick,\n        upperTick,\n        lamportA\n      ).liquity;\n    } else {\n      invariant(lamportB !== null);\n      liquity = this.calculateLiquityByTokenB(\n        lowerTick,\n        upperTick,\n        lamportB\n      ).liquity;\n    }\n\n    const slidRes = calculateSlidTokenAmount(\n      lowerTick,\n      upperTick,\n      liquity,\n      this.tokenSwapInfo.currentSqrtPrice,\n      slid\n    );\n    return {\n      liquity: liquity.toDecimalPlaces(0),\n      amountA: slidRes.amountA.toDecimalPlaces(0),\n      amountB: slidRes.amountB.toDecimalPlaces(0),\n      maximumAmountA: slidRes.maxAmountA.toDecimalPlaces(0),\n      maximumAmountB: slidRes.maxAmountB.toDecimalPlaces(0),\n      minimumAmountA: slidRes.minAmountA.toDecimalPlaces(0),\n      minimumAmountB: slidRes.minAmountB.toDecimalPlaces(0),\n    };\n  }\n\n  /**\n   * Calculate the position current value\n   * @param positionId The position id\n   * @returns The amount of token A and token B\n   */\n  calculatePositionValue(positionId: PublicKey): {\n    liquity: Decimal;\n    amountA: Decimal;\n    amountB: Decimal;\n  } {\n    invariant(this.isLoaded, \"The token swap not load\");\n    const positionInfo = this.getPositionInfo(positionId);\n    invariant(\n      positionInfo !== undefined,\n      `The position:${positionId.toBase58()} not found`\n    );\n    const { amountA, amountB } = calculateTokenAmount(\n      positionInfo.lowerTick,\n      positionInfo.upperTick,\n      positionInfo.liquity,\n      this.tokenSwapInfo.currentSqrtPrice\n    );\n    return {\n      liquity: positionInfo.liquity,\n      amountA,\n      amountB,\n    };\n  }\n\n  calculatePositionValueWithSlid(\n    positionId: PublicKey,\n    percentage: Decimal = new Decimal(1),\n    slid: Decimal = new Decimal(0.01)\n  ): {\n    liquity: Decimal;\n    maxAmountA: Decimal;\n    minAmountA: Decimal;\n    maxAmountB: Decimal;\n    minAmountB: Decimal;\n    amountA: Decimal;\n    amountB: Decimal;\n  } {\n    invariant(this.isLoaded, \"The token swap not load\");\n    invariant(\n      percentage.greaterThan(0) && percentage.lessThanOrEqualTo(1),\n      `Invalid pencentage:${percentage.toString()}`\n    );\n    const positionInfo = this.getPositionInfo(positionId);\n    invariant(\n      positionInfo !== undefined,\n      `The position:${positionId.toBase58()} not found`\n    );\n    const liquity = positionInfo.liquity.mul(percentage).toDecimalPlaces(0);\n    const res = calculateSlidTokenAmount(\n      positionInfo.lowerTick,\n      positionInfo.upperTick,\n      liquity,\n      this.tokenSwapInfo.currentSqrtPrice,\n      slid\n    );\n    return {\n      liquity,\n      ...res,\n    };\n  }\n\n  /**\n   * prepare calculate claim amount of token A and B\n   * @param positionId The position id\n   * @returns the amount of token A and B\n   */\n  preClaim(positionId: PublicKey): { amountA: Decimal; amountB: Decimal } {\n    invariant(this.isLoaded, \"The token swap not load\");\n    const positionInfo = this.getPositionInfo(positionId);\n    invariant(\n      positionInfo !== undefined,\n      `The position:${positionId.toBase58()} not found`\n    );\n    let lowerTick: Tick | null = null;\n    let upperTick: Tick | null = null;\n    for (let i = 0; i < this.ticks.length; i++) {\n      const tick = this.ticks[i];\n      invariant(tick !== undefined);\n      if (tick.tick === positionInfo.lowerTick) {\n        lowerTick = tick;\n      }\n      if (tick.tick === positionInfo.upperTick) {\n        upperTick = tick;\n      }\n    }\n    invariant(\n      lowerTick !== null,\n      `The position lower tick:${positionInfo.lowerTick} not found`\n    );\n    invariant(\n      upperTick !== null,\n      `The position upper tick:${positionInfo.upperTick} not found`\n    );\n\n    let lowerFeeOutSideA = new Decimal(0);\n    let lowerFeeOutSideB = new Decimal(0);\n    let upperFeeOutSideA = new Decimal(0);\n    let upperFeeOutSideB = new Decimal(0);\n    const currentSqrtPrice = this.tokenSwapInfo.currentSqrtPrice;\n\n    if (lowerTick.tickPrice.lessThan(currentSqrtPrice)) {\n      lowerFeeOutSideA = lowerTick.feeGrowthOutside0;\n      lowerFeeOutSideB = lowerTick.feeGrowthOutside1;\n    } else {\n      lowerFeeOutSideA = this.tokenSwapInfo.feeGrowthGlobal0.sub(\n        lowerTick.feeGrowthOutside0\n      );\n      lowerFeeOutSideB = this.tokenSwapInfo.feeGrowthGlobal1.sub(\n        lowerTick.feeGrowthOutside1\n      );\n    }\n\n    if (upperTick.tickPrice.lessThan(currentSqrtPrice)) {\n      upperFeeOutSideA = this.tokenSwapInfo.feeGrowthGlobal0.sub(\n        upperTick.feeGrowthOutside0\n      );\n      upperFeeOutSideB = this.tokenSwapInfo.feeGrowthGlobal1.sub(\n        upperTick.feeGrowthOutside1\n      );\n    } else {\n      upperFeeOutSideA = upperTick.feeGrowthOutside0;\n      upperFeeOutSideB = upperTick.feeGrowthOutside1;\n    }\n\n    return {\n      amountA: this.tokenSwapInfo.feeGrowthGlobal0\n        .sub(lowerFeeOutSideA)\n        .sub(upperFeeOutSideA)\n        .sub(positionInfo.feeGrowthInsideALast)\n        .mul(positionInfo.liquity)\n        .add(positionInfo.tokenAFee),\n      amountB: this.tokenSwapInfo.feeGrowthGlobal1\n        .sub(lowerFeeOutSideB)\n        .sub(upperFeeOutSideB)\n        .sub(positionInfo.feeGrowthInsideBLast)\n        .mul(positionInfo.liquity)\n        .add(positionInfo.tokenBFee),\n    };\n  }\n\n  /**\n   * Prepare calculate A swap B\n   * @param amountIn The amount input of token A\n   * @returns amountOut:The amount out of token B, amountUsed:The used of amountIn, afterPrice:The price after calculate, afterLiquity: The liquity after calculate\n   */\n  preSwapA(amountIn: Decimal): {\n    amountOut: Decimal;\n    amountUsed: Decimal;\n    feeUsed: Decimal;\n    afterLiquity: Decimal;\n    impactA: Decimal;\n    impactB: Decimal;\n    transactionPriceA: Decimal;\n    transactionPriceB: Decimal;\n    afterPriceA: Decimal;\n    afterPriceB: Decimal;\n    revert: boolean;\n    revertReason: string;\n  } {\n    invariant(this.isLoaded, \"The token swap not load\");\n    const res = calculateSwapA2B(\n      this.ticks,\n      this.tokenSwapInfo.currentSqrtPrice,\n      this.tokenSwapInfo.fee,\n      this.tokenSwapInfo.currentLiquity,\n      amountIn\n    );\n    const currentPriceA = this.uiPrice();\n    const currentPriceB = this.uiReversePrice();\n    const transactionPriceA = res.amountOut.div(res.amountUsed);\n    const transactionPriceB = res.amountUsed.div(res.amountOut);\n    const impactA = transactionPriceA\n      .sub(currentPriceA)\n      .div(currentPriceA)\n      .abs();\n    const impactB = transactionPriceB\n      .sub(currentPriceB)\n      .div(currentPriceB)\n      .abs();\n\n    const afterPriceA = res.afterPrice.pow(2);\n    const afterPriceB = new Decimal(1).div(afterPriceA);\n\n    const revert = res.amountUsed.lessThan(amountIn);\n    const revertReason = revert ? \"Insufficient liquidity\" : \"\";\n\n    return {\n      amountOut: res.amountOut,\n      amountUsed: res.amountUsed,\n      feeUsed: res.feeUsed,\n      afterPriceA,\n      afterPriceB,\n      afterLiquity: res.afterLiquity,\n      impactA,\n      impactB,\n      transactionPriceA,\n      transactionPriceB,\n      revert,\n      revertReason,\n    };\n  }\n\n  /**\n   * Prepare calculate B swap A\n   * @param amountIn The amount input of token B\n   * @returns amountOut:The amount out of token A, amountUsed:The used of amountIn, afterPrice:The price after calculate, afterLiquity: The liquity after calculate\n   */\n  preSwapB(amountIn: Decimal): {\n    amountOut: Decimal;\n    amountUsed: Decimal;\n    feeUsed: Decimal;\n    afterLiquity: Decimal;\n    impactA: Decimal;\n    impactB: Decimal;\n    transactionPriceA: Decimal;\n    transactionPriceB: Decimal;\n    afterPriceA: Decimal;\n    afterPriceB: Decimal;\n    revert: boolean;\n    revertReason: string;\n  } {\n    invariant(this.isLoaded, \"The token swap not load\");\n    const res = calculateSwapB2A(\n      this.ticks,\n      this.tokenSwapInfo.currentSqrtPrice,\n      this.tokenSwapInfo.fee,\n      this.tokenSwapInfo.currentLiquity,\n      amountIn\n    );\n    const currentPriceA = this.tokenSwapInfo.currentSqrtPrice.pow(2);\n    const currentPriceB = new Decimal(1).div(currentPriceA);\n    const transactionPriceA = res.amountUsed.div(res.amountOut);\n    const transactionPriceB = res.amountOut.div(res.amountUsed);\n    const impactA = transactionPriceA\n      .sub(currentPriceA)\n      .div(currentPriceA)\n      .abs();\n    const impactB = transactionPriceB\n      .sub(currentPriceB)\n      .div(currentPriceB)\n      .abs();\n    const afterPriceA = res.afterPrice.pow(2);\n    const afterPriceB = new Decimal(1).div(afterPriceA);\n\n    const revert = res.amountUsed.lessThan(amountIn);\n    const revertReason = revert ? \"Insufficient liquidity\" : \"\";\n\n    return {\n      amountOut: res.amountOut,\n      amountUsed: res.amountUsed,\n      feeUsed: res.feeUsed,\n      afterLiquity: res.afterLiquity,\n      impactA,\n      impactB,\n      transactionPriceA,\n      transactionPriceB,\n      afterPriceA,\n      afterPriceB,\n      revert,\n      revertReason,\n    };\n  }\n\n  /**\n   * Get nearest tick by price\n   * @param price The price\n   * @returns The tick\n   */\n  getNearestTickByPrice(price: Decimal): number {\n    invariant(this.isLoaded, \"The token swap not load\");\n    return getNearestTickByPrice(price, this.tokenSwapInfo.tickSpace);\n  }\n\n  /* @internal */\n  getPositionInfo(positionId: PublicKey): PositionInfo | undefined {\n    invariant(this.isLoaded, \"The token swap not load\");\n    return this.positions.get(positionId.toBase58());\n  }\n\n  /* @internal */\n  choosePosition(): PublicKey | null {\n    invariant(this.isLoaded, \"The token swap not load\");\n    for (const [key, val] of this.positionsKeys) {\n      if (val < MAX_ACCOUNT_POSITION_LENGTH) {\n        return key;\n      }\n    }\n    return null;\n  }\n\n  uiPrice(): Decimal {\n    invariant(this.isLoaded, \"The token swap not load\");\n    return lamportPrice2uiPrice(\n      this.tokenSwapInfo.currentSqrtPrice.pow(2),\n      this.tokenSwapInfo.tokenADecimals,\n      this.tokenSwapInfo.tokenBDecimals\n    );\n  }\n\n  uiReversePrice(): Decimal {\n    invariant(this.isLoaded, \"The token swap not load\");\n    return new Decimal(1).div(this.uiPrice());\n  }\n\n  uiPrice2SwapPrice(price: Decimal): Decimal {\n    invariant(this.isLoaded, \"The token swap not load\");\n    return uiPrice2LamportPrice(\n      price,\n      this.tokenSwapInfo.tokenADecimals,\n      this.tokenSwapInfo.tokenBDecimals\n    );\n  }\n\n  uiPrice2SwapSqrtPrice(price: Decimal): Decimal {\n    invariant(this.isLoaded, \"The token swap not load\");\n    return uiPrice2LamportPrice(\n      price,\n      this.tokenSwapInfo.tokenADecimals,\n      this.tokenSwapInfo.tokenBDecimals\n    ).sqrt();\n  }\n\n  uiReversePrice2SwapPrice(price: Decimal): Decimal {\n    invariant(this.isLoaded, \"The token swap not load\");\n    return uiPrice2LamportPrice(\n      new Decimal(1).div(price),\n      this.tokenSwapInfo.tokenADecimals,\n      this.tokenSwapInfo.tokenBDecimals\n    );\n  }\n\n  uiReversePrice2SwapSqrtPrice(price: Decimal): Decimal {\n    invariant(this.isLoaded, \"The token swap not load\");\n    return uiPrice2LamportPrice(\n      new Decimal(1).div(price),\n      this.tokenSwapInfo.tokenADecimals,\n      this.tokenSwapInfo.tokenBDecimals\n    ).sqrt();\n  }\n\n  uiPrice2Tick(price: Decimal): number {\n    invariant(this.isLoaded, \"The token swap not load\");\n    return uiPrice2Tick(\n      price,\n      this.tokenSwapInfo.tokenADecimals,\n      this.tokenSwapInfo.tokenBDecimals\n    );\n  }\n\n  uiReversePrice2Tick(price: Decimal): number {\n    invariant(this.isLoaded, \"The token swap not load\");\n    return uiPrice2Tick(\n      new Decimal(1).div(price),\n      this.tokenSwapInfo.tokenADecimals,\n      this.tokenSwapInfo.tokenBDecimals\n    );\n  }\n\n  uiPrice2NearestTick(price: Decimal): number {\n    invariant(this.isLoaded, \"The token swap not load\");\n    const swapPrice = uiPrice2LamportPrice(\n      price,\n      this.tokenSwapInfo.tokenADecimals,\n      this.tokenSwapInfo.tokenBDecimals\n    );\n    return this.getNearestTickByPrice(swapPrice);\n  }\n\n  uiReversePrice2NearestTick(price: Decimal): number {\n    invariant(this.isLoaded, \"The token swap not load\");\n    const swapPrice = uiPrice2LamportPrice(\n      new Decimal(1).div(price),\n      this.tokenSwapInfo.tokenADecimals,\n      this.tokenSwapInfo.tokenBDecimals\n    );\n    return this.getNearestTickByPrice(swapPrice);\n  }\n\n  tick2UiPrice(tick: number): Decimal {\n    invariant(this.isLoaded, \"The token swap not load\");\n    return tick2UiPrice(\n      tick,\n      this.tokenSwapInfo.tokenADecimals,\n      this.tokenSwapInfo.tokenBDecimals\n    );\n  }\n\n  tick2UiReversePrice(tick: number): Decimal {\n    invariant(this.isLoaded, \"The token swap not load\");\n    return new Decimal(1).div(\n      tick2UiPrice(\n        tick,\n        this.tokenSwapInfo.tokenADecimals,\n        this.tokenSwapInfo.tokenBDecimals\n      )\n    );\n  }\n\n  tokenALamports(amount: Decimal): Decimal {\n    return amount\n      .mul(new Decimal(10).pow(this.tokenSwapInfo.tokenADecimals))\n      .toDecimalPlaces(0);\n  }\n\n  tokenBLamports(amount: Decimal): Decimal {\n    return amount\n      .mul(new Decimal(10).pow(this.tokenSwapInfo.tokenBDecimals))\n      .toDecimalPlaces(0);\n  }\n\n  tokenAAmount(lamport: Decimal): Decimal {\n    return lamport\n      .toDecimalPlaces(0)\n      .div(new Decimal(10).pow(this.tokenSwapInfo.tokenADecimals));\n  }\n\n  tokenBAmount(lamport: Decimal): Decimal {\n    return lamport\n      .toDecimalPlaces(0)\n      .div(new Decimal(10).pow(this.tokenSwapInfo.tokenBDecimals));\n  }\n\n  calculateEffectivTick(\n    lowerPrice: Decimal,\n    upperPrice: Decimal\n  ): {\n    lowerTick: number;\n    upperTick: number;\n  } {\n    invariant(\n      upperPrice.greaterThan(lowerPrice),\n      \"The upper price must greater than lower price\"\n    );\n    let lowerTick = this.uiPrice2NearestTick(lowerPrice);\n    let upperTick = this.uiPrice2NearestTick(upperPrice);\n    if (lowerTick === upperTick) {\n      const realLowerTick = this.uiPrice2Tick(lowerPrice);\n      const realUpperTick = this.uiPrice2Tick(upperPrice);\n      if (\n        Math.abs(realUpperTick - lowerTick) >\n        Math.abs(realLowerTick - lowerTick)\n      ) {\n        upperTick += this.tokenSwapInfo.tickSpace;\n      } else {\n        lowerTick -= this.tokenSwapInfo.tickSpace;\n      }\n    }\n    return {\n      lowerTick,\n      upperTick,\n    };\n  }\n\n  calculateFixSideTokenAmount(\n    lowerTick: number,\n    upperTick: number,\n    amountA: Decimal | null,\n    amountB: Decimal | null,\n    balanceA: Decimal,\n    balanceB: Decimal,\n    slid: Decimal = new Decimal(0.01)\n  ): {\n    desiredAmountA: Decimal;\n    desiredAmountB: Decimal;\n    maxAmountA: Decimal;\n    maxAmountB: Decimal;\n    desiredDeltaLiquity: Decimal;\n    maxDeltaLiquity: Decimal | undefined;\n    fixTokenType: number;\n    slidPrice: Decimal;\n  } {\n    let maxAmountA = new Decimal(0);\n    let maxAmountB = new Decimal(0);\n    let desiredAmountA = new Decimal(0);\n    let desiredAmountB = new Decimal(0);\n    let desiredDeltaLiquity = new Decimal(0);\n    let maxDeltaLiquity: Decimal | undefined = new Decimal(0);\n    let fixTokenType = FIX_TOKEN_A;\n    let slidSqrtPrice = new Decimal(0);\n    // Fix token a\n    if (amountA !== null) {\n      invariant(amountA.lessThanOrEqualTo(balanceA));\n      const lamportsA = this.tokenALamports(amountA);\n      desiredAmountA = lamportsA;\n      maxAmountA = lamportsA;\n      const res = this.calculateLiquityByTokenA(\n        lowerTick,\n        upperTick,\n        lamportsA\n      );\n      desiredAmountB = res.desiredAmountB;\n      desiredDeltaLiquity = res.liquity;\n      invariant(\n        desiredAmountB.lessThanOrEqualTo(balanceB),\n        \"The fixed amount of token A is too large\"\n      );\n\n      slidSqrtPrice = this.tokenSwapInfo.currentSqrtPrice.mul(\n        new Decimal(1).add(slid).sqrt()\n      );\n      if (slidSqrtPrice.greaterThanOrEqualTo(tick2SqrtPrice(upperTick))) {\n        slidSqrtPrice = tick2SqrtPrice(upperTick - 1);\n      }\n      const slidRes = this.calculateLiquityByTokenA(\n        lowerTick,\n        upperTick,\n        lamportsA,\n        slidSqrtPrice\n      );\n      if (slidRes.desiredAmountB.greaterThan(balanceB)) {\n        maxAmountB = balanceB;\n        maxDeltaLiquity = undefined;\n      } else {\n        maxAmountB = slidRes.desiredAmountB;\n        maxDeltaLiquity = slidRes.liquity;\n      }\n    } else {\n      invariant(\n        amountB !== null,\n        \"You must specified the amount of token A or token B\"\n      );\n      invariant(amountB.lessThanOrEqualTo(balanceB));\n      const lamportsB = this.tokenBLamports(amountB);\n      fixTokenType = FIX_TOKEN_B;\n      desiredAmountB = lamportsB;\n      maxAmountB = lamportsB;\n      const res = this.calculateLiquityByTokenB(\n        lowerTick,\n        upperTick,\n        lamportsB\n      );\n      desiredAmountA = res.desiredAmountA;\n      desiredDeltaLiquity = res.liquity;\n      invariant(\n        desiredAmountA.lessThanOrEqualTo(balanceA),\n        \"The fixed amount of token B is too large\"\n      );\n\n      slidSqrtPrice = this.tokenSwapInfo.currentSqrtPrice.mul(\n        new Decimal(1).sub(slid).sqrt()\n      );\n      if (slidSqrtPrice.lessThanOrEqualTo(tick2SqrtPrice(lowerTick))) {\n        slidSqrtPrice = tick2SqrtPrice(lowerTick + 1);\n      }\n      const slidRes = this.calculateLiquityByTokenB(\n        lowerTick,\n        upperTick,\n        lamportsB,\n        slidSqrtPrice\n      );\n      if (slidRes.desiredAmountA.greaterThan(balanceA)) {\n        maxAmountA = balanceA;\n        maxDeltaLiquity = undefined;\n      } else {\n        maxAmountA = slidRes.desiredAmountA;\n        maxDeltaLiquity = slidRes.liquity;\n      }\n    }\n\n    return {\n      desiredAmountA,\n      desiredAmountB,\n      maxAmountA,\n      maxAmountB,\n      desiredDeltaLiquity,\n      maxDeltaLiquity,\n      fixTokenType,\n      slidPrice: this.tick2UiPrice(sqrtPrice2Tick(slidSqrtPrice)),\n    };\n  }\n\n  async wrapSOL(amount: Decimal): Promise<TransactionEnvelope> {\n    invariant(amount.greaterThan(0));\n    const tx = new TransactionEnvelope(this.provider, []);\n    const { address: ataAddress, instruction: ataInstruction } =\n      await getOrCreateATA({\n        provider: this.provider,\n        mint: NATIVE_MINT,\n        owner: this.provider.wallet.publicKey,\n        payer: this.provider.wallet.publicKey,\n      });\n    if (ataInstruction !== null) {\n      tx.instructions.push(ataInstruction);\n    }\n    tx.instructions.push(\n      SystemProgram.transfer({\n        fromPubkey: this.provider.wallet.publicKey,\n        toPubkey: ataAddress,\n        lamports: amount.toNumber(),\n      })\n    );\n    tx.instructions.push(createSyncNativeInstruction(ataAddress));\n    return tx;\n  }\n\n  async unwrapSOL(\n    ataAddress: PublicKey,\n    dest: PublicKey = this.provider.wallet.publicKey\n  ): Promise<TransactionEnvelope> {\n    const checkAta = await getATAAddress({\n      mint: NATIVE_MINT,\n      owner: this.provider.wallet.publicKey,\n    });\n    invariant(ataAddress.equals(checkAta), \"Only allow close wrap SOL ata\");\n    const tx = createCloseAccountInstruction(\n      ataAddress,\n      dest,\n      this.provider.wallet.publicKey\n    );\n    return new TransactionEnvelope(this.provider, [tx]);\n  }\n\n  private async _checkUserPositionAccount(\n    positionId: PublicKey,\n    positionAccount: PublicKey | null\n  ): Promise<{\n    positionInfo: PositionInfo;\n    positionAccount: PublicKey;\n  }> {\n    if (!this.isLoaded) {\n      await this.load();\n    }\n    const positionInfo = this.getPositionInfo(positionId);\n    invariant(\n      positionInfo !== undefined,\n      `Position:${positionId.toString()} not found`\n    );\n    if (positionAccount === null) {\n      positionAccount = await getATAAddress({\n        mint: positionId,\n        owner: this.provider.wallet.publicKey,\n      });\n    }\n    const positionAccountInfo = await getTokenAccount(\n      this.provider,\n      positionAccount\n    );\n    invariant(\n      positionAccountInfo.mint.toString() === positionId.toString(),\n      `Invalid position account:${positionAccount.toBase58()}`\n    );\n    invariant(\n      positionAccountInfo.amount.toNumber() === 1,\n      `You not hold this position:${positionId.toBase58()}`\n    );\n    return {\n      positionInfo,\n      positionAccount,\n    };\n  }\n}\n"]}